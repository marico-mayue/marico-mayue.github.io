<!doctype html>



  


<html class="theme-next pisces use-motion">
<head><meta name="generator" content="Hexo 3.9.0">
  <meta charset="UTF-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">



<meta http-equiv="Cache-Control" content="no-transform">
<meta http-equiv="Cache-Control" content="no-siteapp">












  
  
  <link href="/vendors/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css">




  
  
  
  

  
    
    
  

  
    
      
    

    
  

  

  
    
      
    

    
  

  
    
      
    

    
  

  
    
    
    <link href="//fonts.googleapis.com/css?family=Monda:300,300italic,400,400italic,700,700italic|Roboto Slab:300,300italic,400,400italic,700,700italic|Lobster Two:300,300italic,400,400italic,700,700italic|PT Mono:300,300italic,400,400italic,700,700italic&subset=latin,latin-ext" rel="stylesheet" type="text/css">
  






<link href="/vendors/font-awesome/css/font-awesome.min.css?v=4.4.0" rel="stylesheet" type="text/css">

<link href="/css/main.css?v=5.0.1" rel="stylesheet" type="text/css">


  <meta name="keywords" content="年度总结,">








  <link rel="shortcut icon" type="image/x-icon" href="/images/avatar.png?v=5.0.1">






<meta name="description" content="2019前端体系及核心知识点总结深冻结1234567891011121314151617181920212223let person = &amp;#123;  name: &amp;apos;aaa&amp;apos;,  lesson: &amp;#123;    name: &amp;apos;english&amp;apos;,    type: &amp;apos;basic&amp;apos;  &amp;#125;&amp;#125;;function deep">
<meta name="keywords" content="年度总结">
<meta property="og:type" content="article">
<meta property="og:title" content="2019 Year in Review">
<meta property="og:url" content="http://yoursite.com/2019/12/22/2019 Year in Review/index.html">
<meta property="og:site_name" content="MaYue&#39;s Notes">
<meta property="og:description" content="2019前端体系及核心知识点总结深冻结1234567891011121314151617181920212223let person = &amp;#123;  name: &amp;apos;aaa&amp;apos;,  lesson: &amp;#123;    name: &amp;apos;english&amp;apos;,    type: &amp;apos;basic&amp;apos;  &amp;#125;&amp;#125;;function deep">
<meta property="og:locale" content="zh-Hans">
<meta property="og:updated_time" content="2020-02-03T13:59:50.591Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="2019 Year in Review">
<meta name="twitter:description" content="2019前端体系及核心知识点总结深冻结1234567891011121314151617181920212223let person = &amp;#123;  name: &amp;apos;aaa&amp;apos;,  lesson: &amp;#123;    name: &amp;apos;english&amp;apos;,    type: &amp;apos;basic&amp;apos;  &amp;#125;&amp;#125;;function deep">



<script type="text/javascript" id="hexo.configuration">
  var NexT = window.NexT || {};
  var CONFIG = {
    scheme: 'Pisces',
    sidebar: {"position":"left","display":"post"},
    fancybox: true,
    motion: true,
    duoshuo: {
      userId: 0,
      author: '博主'
    }
  };
</script>




  <link rel="canonical" href="http://yoursite.com/2019/12/22/2019 Year in Review/">

  <title> 2019 Year in Review | MaYue's Notes </title>
</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  










  
  
    
  

  <div class="container one-collumn sidebar-position-left page-post-detail ">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-meta ">
  

  <div class="custom-logo-site-title">
    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <span class="site-title">MaYue's Notes</span>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>
  <p class="site-subtitle">Quick notes</p>
</div>

<div class="site-nav-toggle">
  <button>
    <span class="btn-bar"></span>
    <span class="btn-bar"></span>
    <span class="btn-bar"></span>
  </button>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br>
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-categories">
          <a href="/categories" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-th"></i> <br>
            
            分类
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br>
            
            标签
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br>
            
            归档
          </a>
        </li>
      
        
        <li class="menu-item menu-item-about">
          <a href="/about" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-user"></i> <br>
            
            关于
          </a>
        </li>
      

      
        <li class="menu-item menu-item-search">
          
            <a href="javascript:;" class="st-search-show-outputs">
          
            
              <i class="menu-item-icon fa fa-search fa-fw"></i> <br>
            
            搜索
          </a>
        </li>
      
    </ul>
  

  
    <div class="site-search">
      
  <form class="site-search-form">
  <input type="text" id="st-search-input" class="st-search-input st-default-search-input">
</form>

<script type="text/javascript">
  (function(w,d,t,u,n,s,e){w['SwiftypeObject']=n;w[n]=w[n]||function(){
    (w[n].q=w[n].q||[]).push(arguments);};s=d.createElement(t);
    e=d.getElementsByTagName(t)[0];s.async=1;s.src=u;e.parentNode.insertBefore(s,e);
  })(window,document,'script','//s.swiftypecdn.com/install/v2/st.js','_st');

  _st('install', '我的博客笔记','2.0.0');
</script>



    </div>
  
</nav>

 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            

  <div id="posts" class="posts-expand">
    

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                2019 Year in Review
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">发表于</span>
            <time itemprop="dateCreated" datetime="2019-12-22T00:00:00+08:00" content="2019-12-22">
              2019-12-22
            </time>
          </span>

          
            <span class="post-category">
              &nbsp; | &nbsp;
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
              
                <span itemprop="about" itemscope itemtype="https://schema.org/Thing">
                  <a href="/categories/年度总结/" itemprop="url" rel="index">
                    <span itemprop="name">年度总结</span>
                  </a>
                </span>

                
                

              
            </span>
          

          
            
              <span class="post-comments-count">
                &nbsp; | &nbsp;
                <a href="/2019/12/22/2019 Year in Review/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count ds-thread-count" data-thread-key="2019/12/22/2019 Year in Review/" itemprop="commentsCount"></span>
                </a>
              </span>
            
          

          

          
          

          
        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        <h3 id="2019前端体系及核心知识点总结"><a href="#2019前端体系及核心知识点总结" class="headerlink" title="2019前端体系及核心知识点总结"></a>2019前端体系及核心知识点总结</h3><h4 id="深冻结"><a href="#深冻结" class="headerlink" title="深冻结"></a>深冻结</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">let person = &#123;</span><br><span class="line">  name: &apos;aaa&apos;,</span><br><span class="line">  lesson: &#123;</span><br><span class="line">    name: &apos;english&apos;,</span><br><span class="line">    type: &apos;basic&apos;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">function deepFreeze(obj) &#123;</span><br><span class="line">  let propNames = Object.getOwnPropertyNames(obj);</span><br><span class="line"></span><br><span class="line">  for (let name of propNames) &#123;</span><br><span class="line">    let value = obj[name];</span><br><span class="line"></span><br><span class="line">    obj[name] = value &amp;&amp; typeof value === &apos;object&apos; ? deepFreeze(value) : value;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  return Object.freeze(obj);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">deepFreeze(person);</span><br><span class="line"></span><br><span class="line">person.lesson.name = 123;</span><br></pre></td></tr></table></figure>
<h4 id="防抖"><a href="#防抖" class="headerlink" title="防抖"></a>防抖</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">debounce(fn, delay) &#123;</span><br><span class="line">  let timer = null;</span><br><span class="line"></span><br><span class="line">  return (...args) =&gt; &#123;</span><br><span class="line">    if (timer) &#123;</span><br><span class="line">      clearTimeout(timer);</span><br><span class="line">      timer = null;</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">      timer = setTimeout(() =&gt; &#123;</span><br><span class="line">        fn.apply(this, args);</span><br><span class="line">      &#125;, delay);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="节流"><a href="#节流" class="headerlink" title="节流"></a>节流</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line">// 定时器实现</span><br><span class="line">throttle(fn, delay) &#123;</span><br><span class="line">  let timer = null;</span><br><span class="line"></span><br><span class="line">  return (...args) =&gt; &#123;</span><br><span class="line">    if (!timer) &#123;</span><br><span class="line">      timer = setTimeout(() =&gt; &#123;</span><br><span class="line">        fn.apply(this, args);</span><br><span class="line">        clearTimeout(timer);</span><br><span class="line">        timer = null;</span><br><span class="line">      &#125;, delay);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 时间戳实现</span><br><span class="line">throttle(fn, delay) &#123;</span><br><span class="line">  let startTime = Date.now();</span><br><span class="line"></span><br><span class="line">  return (...args) =&gt; &#123;</span><br><span class="line">    let curTime = Date.now();</span><br><span class="line"></span><br><span class="line">    if (curTime - startTime &gt;= delay) &#123;</span><br><span class="line">      fn.apply(this, args);</span><br><span class="line">      startTime = Date.now();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 时间戳 + 定时器实现</span><br><span class="line">// 保证第一次触发事件就能立即执行事件处理函数和每隔 delay 时间执行一次事件处理函数</span><br><span class="line">throttle(fn, delay) &#123;</span><br><span class="line">  let timer = null;</span><br><span class="line">  let startTime = Date.now();</span><br><span class="line"></span><br><span class="line">  return (...args) =&gt; &#123;</span><br><span class="line">    let curTime = Date.now();</span><br><span class="line">    let remainTime = delay - (curTime - startTime);</span><br><span class="line"></span><br><span class="line">    clearTimeout(timer);</span><br><span class="line"></span><br><span class="line">    if (remainTime &lt;= 0) &#123;</span><br><span class="line">      fn.apply(this, args);</span><br><span class="line">      startTime = Date.now();</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">      timer = setTimeout(fn, remainTime);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<a id="more"></a>
<h4 id="可存储函数执行结果的函数"><a href="#可存储函数执行结果的函数" class="headerlink" title="可存储函数执行结果的函数"></a>可存储函数执行结果的函数</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">memeorize(fn) &#123;</span><br><span class="line">  let cache = &#123;&#125;;</span><br><span class="line"></span><br><span class="line">  return (...args) =&gt; &#123;</span><br><span class="line">    const key = args.toString();</span><br><span class="line"></span><br><span class="line">    if (cache[key]) &#123;</span><br><span class="line">      return cache[key];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    let value = fn.apply(this, args);</span><br><span class="line">    cache[key] = value;</span><br><span class="line"></span><br><span class="line">    return value;</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="将函数转化为-Promise-的使用"><a href="#将函数转化为-Promise-的使用" class="headerlink" title="将函数转化为 Promise 的使用"></a>将函数转化为 Promise 的使用</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">promisy(fn) &#123;</span><br><span class="line">  return (...args) =&gt; &#123;</span><br><span class="line">    return new Promise((resolve, reject) =&gt; &#123;</span><br><span class="line">      try &#123;</span><br><span class="line">        fn(...args, resolve);</span><br><span class="line">      &#125; catch (e) &#123;</span><br><span class="line">        reject(e);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="函数柯里化"><a href="#函数柯里化" class="headerlink" title="函数柯里化"></a>函数柯里化</h4><blockquote>
<p>柯里化（Currying）是把接受多个参数的函数变换成接受一个单一参数（最初函数的第一个参数）的函数，并且返回接受余下的参数且返回结果的新函数的技术<br>参数复用、提前返回和延迟执行<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">// Tips：伪数组转真数组</span><br><span class="line">// Array.prototype.slice.call(&#123;</span><br><span class="line">//   length: 2,</span><br><span class="line">//   &apos;0&apos;: &apos;123&apos;,</span><br><span class="line">//   &apos;1&apos;: &apos;aaa&apos;</span><br><span class="line">// &#125;);</span><br><span class="line">// let argsArr = [].slice.call(arguments);</span><br></pre></td></tr></table></figure></p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line">currying(fn) &#123;</span><br><span class="line">  let allArgs = [];</span><br><span class="line"></span><br><span class="line">  function next () &#123;</span><br><span class="line">    let args = Array.prototype.slice.call(arguments);</span><br><span class="line"></span><br><span class="line">    allArgs = [...allArgs, ...args];</span><br><span class="line"></span><br><span class="line">    return next;</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  // 字符类型</span><br><span class="line">  next.toString = function() &#123;</span><br><span class="line">    return fn.apply(null, allArgs);</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  // 数值类型</span><br><span class="line">  next.valueOf = function() &#123;</span><br><span class="line">    return fn.apply(null, allArgs);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  return next;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">currying(fun) &#123;</span><br><span class="line">  function helper(fn, ...arg1) &#123;</span><br><span class="line">    let length = fn.length;</span><br><span class="line">    let self = this;</span><br><span class="line"></span><br><span class="line">    return function(...arg2) &#123;</span><br><span class="line">      let arg = arg1.concat(arg2);</span><br><span class="line"></span><br><span class="line">      if (arg.length &lt; length) &#123;</span><br><span class="line">        return helper.call(self, fn, ...arg);</span><br><span class="line">      &#125; else &#123;</span><br><span class="line">        return fn.apply(this, arg);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  return helper(fun);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line">// 认识真相的五大阻力：</span><br><span class="line">// 从众心理</span><br><span class="line">// 认知偏见</span><br><span class="line">// 情绪干扰</span><br><span class="line">// 思维局限</span><br><span class="line">// 逻辑谬误</span><br><span class="line"></span><br><span class="line">// 选择、时机和运气</span><br><span class="line"></span><br><span class="line">// BEM</span><br><span class="line">// OOCSS</span><br><span class="line">// OOSASS</span><br><span class="line">// SMACSS</span><br><span class="line"></span><br><span class="line">// p-页面（Page）（应用于body元素的类）对可维护性不是那么重要的静态页面十分有用 —应该避免嵌套使用 (例: p-Homepage);</span><br><span class="line">// l-布局（Layout）, 比如列（columning），包裹（wrappers） 和容器（containers）等等(例: l-Masthead, l-Footer);</span><br><span class="line">// c-组件（components ）(例: c-Dropdown, c-Button…);</span><br><span class="line">// u-公共类（Utility classes） — 不会发生改变, 在代码的任何地方都不能重载。(例: u-textCenter, u-clearfix…);</span><br><span class="line">// js-JavaScript钩子：永远不应该出现在CSS中；</span><br><span class="line">// g-JavaScript钩子：全局js类，永远不应该出现在CSS中；</span><br><span class="line"></span><br><span class="line">// Serverless = FaaS + BaaS</span><br><span class="line">// 事件驱动：函数在 FaaS 平台中，需要通过一系列的事件来驱动函数执行。</span><br><span class="line">// 无状态：因为每次函数执行，可能使用的都是不同的容器，无法进行内存或数据共享。如果要共享数据，则只能通过第三方服务，比如 Redis 等。</span><br><span class="line">// 无运维：使用 Serverless 我们不需要关心服务器，不需要关心运维。这也是 Serverless 思想的核心。</span><br><span class="line">// 低成本：使用 Serverless 成本很低，因为我们只需要为每次函数的运行付费。函数不运行，则不花钱，也不会浪费服务器资源</span><br><span class="line">// 存在问题：标准不统一</span><br><span class="line"></span><br><span class="line">// SSR解决：白屏时间和SEO</span><br><span class="line">// SSR问题：运维成本</span><br><span class="line">// SSR路由 －&gt; Serverless函数</span><br><span class="line">// https://pic2.zhimg.com/80/v2-937eabff94a6c53b2d53d105332dc001_hd.jpg</span><br><span class="line"></span><br><span class="line">// 运用场景：小程序云开发</span><br><span class="line"></span><br><span class="line">// 函数测试：</span><br><span class="line">// 1、将业务逻辑和函数依赖的 FaaS 和 BaaS 分离</span><br><span class="line">// 2、对业务逻辑进行充分的单元测试</span><br><span class="line">// 3、将函数进行集成测试验证代码是否正常工作</span><br><span class="line"></span><br><span class="line">// 函数性能：（优化冷启动时间）</span><br><span class="line">// 函数生命周期：https://pic4.zhimg.com/80/v2-c440550443505856d11efa6efe86d623_hd.jpg</span><br><span class="line">// 1、选用 Node.js / Python 等冷启动时间短的编程语言</span><br><span class="line">// 2、为函数分配合适的运行内存 函数不是每次都冷启动，而是会在一定时间内复用之前的运行环境!</span><br><span class="line">// 3、执行上下文重用</span><br><span class="line">// 4、给函数“预热”（隔一段时间就冷启动一个运行环境）</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br><span class="line">296</span><br><span class="line">297</span><br><span class="line">298</span><br><span class="line">299</span><br><span class="line">300</span><br><span class="line">301</span><br><span class="line">302</span><br><span class="line">303</span><br><span class="line">304</span><br><span class="line">305</span><br><span class="line">306</span><br><span class="line">307</span><br><span class="line">308</span><br><span class="line">309</span><br><span class="line">310</span><br><span class="line">311</span><br><span class="line">312</span><br><span class="line">313</span><br><span class="line">314</span><br><span class="line">315</span><br><span class="line">316</span><br><span class="line">317</span><br><span class="line">318</span><br><span class="line">319</span><br><span class="line">320</span><br><span class="line">321</span><br><span class="line">322</span><br><span class="line">323</span><br><span class="line">324</span><br><span class="line">325</span><br><span class="line">326</span><br><span class="line">327</span><br><span class="line">328</span><br><span class="line">329</span><br><span class="line">330</span><br><span class="line">331</span><br><span class="line">332</span><br><span class="line">333</span><br><span class="line">334</span><br><span class="line">335</span><br><span class="line">336</span><br><span class="line">337</span><br><span class="line">338</span><br><span class="line">339</span><br><span class="line">340</span><br><span class="line">341</span><br><span class="line">342</span><br><span class="line">343</span><br><span class="line">344</span><br><span class="line">345</span><br><span class="line">346</span><br><span class="line">347</span><br><span class="line">348</span><br><span class="line">349</span><br><span class="line">350</span><br><span class="line">351</span><br><span class="line">352</span><br><span class="line">353</span><br><span class="line">354</span><br><span class="line">355</span><br><span class="line">356</span><br><span class="line">357</span><br><span class="line">358</span><br><span class="line">359</span><br><span class="line">360</span><br><span class="line">361</span><br><span class="line">362</span><br><span class="line">363</span><br><span class="line">364</span><br><span class="line">365</span><br><span class="line">366</span><br><span class="line">367</span><br><span class="line">368</span><br><span class="line">369</span><br><span class="line">370</span><br><span class="line">371</span><br><span class="line">372</span><br><span class="line">373</span><br><span class="line">374</span><br><span class="line">375</span><br><span class="line">376</span><br><span class="line">377</span><br><span class="line">378</span><br><span class="line">379</span><br><span class="line">380</span><br><span class="line">381</span><br><span class="line">382</span><br><span class="line">383</span><br><span class="line">384</span><br><span class="line">385</span><br><span class="line">386</span><br><span class="line">387</span><br><span class="line">388</span><br><span class="line">389</span><br><span class="line">390</span><br><span class="line">391</span><br><span class="line">392</span><br><span class="line">393</span><br><span class="line">394</span><br><span class="line">395</span><br><span class="line">396</span><br><span class="line">397</span><br><span class="line">398</span><br><span class="line">399</span><br><span class="line">400</span><br><span class="line">401</span><br><span class="line">402</span><br><span class="line">403</span><br><span class="line">404</span><br><span class="line">405</span><br><span class="line">406</span><br><span class="line">407</span><br><span class="line">408</span><br><span class="line">409</span><br><span class="line">410</span><br><span class="line">411</span><br><span class="line">412</span><br><span class="line">413</span><br><span class="line">414</span><br><span class="line">415</span><br><span class="line">416</span><br><span class="line">417</span><br><span class="line">418</span><br><span class="line">419</span><br><span class="line">420</span><br><span class="line">421</span><br><span class="line">422</span><br><span class="line">423</span><br><span class="line">424</span><br><span class="line">425</span><br><span class="line">426</span><br><span class="line">427</span><br><span class="line">428</span><br><span class="line">429</span><br><span class="line">430</span><br><span class="line">431</span><br><span class="line">432</span><br><span class="line">433</span><br><span class="line">434</span><br><span class="line">435</span><br><span class="line">436</span><br><span class="line">437</span><br><span class="line">438</span><br><span class="line">439</span><br><span class="line">440</span><br><span class="line">441</span><br><span class="line">442</span><br><span class="line">443</span><br><span class="line">444</span><br><span class="line">445</span><br><span class="line">446</span><br><span class="line">447</span><br><span class="line">448</span><br><span class="line">449</span><br><span class="line">450</span><br><span class="line">451</span><br><span class="line">452</span><br><span class="line">453</span><br><span class="line">454</span><br><span class="line">455</span><br><span class="line">456</span><br><span class="line">457</span><br><span class="line">458</span><br><span class="line">459</span><br><span class="line">460</span><br><span class="line">461</span><br><span class="line">462</span><br><span class="line">463</span><br><span class="line">464</span><br><span class="line">465</span><br><span class="line">466</span><br><span class="line">467</span><br><span class="line">468</span><br><span class="line">469</span><br><span class="line">470</span><br><span class="line">471</span><br><span class="line">472</span><br><span class="line">473</span><br><span class="line">474</span><br><span class="line">475</span><br><span class="line">476</span><br><span class="line">477</span><br><span class="line">478</span><br><span class="line">479</span><br><span class="line">480</span><br><span class="line">481</span><br><span class="line">482</span><br><span class="line">483</span><br><span class="line">484</span><br><span class="line">485</span><br><span class="line">486</span><br><span class="line">487</span><br><span class="line">488</span><br><span class="line">489</span><br><span class="line">490</span><br><span class="line">491</span><br><span class="line">492</span><br><span class="line">493</span><br><span class="line">494</span><br><span class="line">495</span><br><span class="line">496</span><br><span class="line">497</span><br><span class="line">498</span><br><span class="line">499</span><br><span class="line">500</span><br><span class="line">501</span><br><span class="line">502</span><br><span class="line">503</span><br><span class="line">504</span><br><span class="line">505</span><br><span class="line">506</span><br><span class="line">507</span><br><span class="line">508</span><br><span class="line">509</span><br><span class="line">510</span><br><span class="line">511</span><br><span class="line">512</span><br><span class="line">513</span><br><span class="line">514</span><br><span class="line">515</span><br><span class="line">516</span><br><span class="line">517</span><br><span class="line">518</span><br><span class="line">519</span><br><span class="line">520</span><br><span class="line">521</span><br><span class="line">522</span><br><span class="line">523</span><br><span class="line">524</span><br><span class="line">525</span><br><span class="line">526</span><br><span class="line">527</span><br><span class="line">528</span><br><span class="line">529</span><br><span class="line">530</span><br><span class="line">531</span><br><span class="line">532</span><br><span class="line">533</span><br><span class="line">534</span><br><span class="line">535</span><br><span class="line">536</span><br><span class="line">537</span><br><span class="line">538</span><br><span class="line">539</span><br><span class="line">540</span><br><span class="line">541</span><br><span class="line">542</span><br><span class="line">543</span><br><span class="line">544</span><br><span class="line">545</span><br><span class="line">546</span><br><span class="line">547</span><br><span class="line">548</span><br><span class="line">549</span><br><span class="line">550</span><br><span class="line">551</span><br><span class="line">552</span><br><span class="line">553</span><br><span class="line">554</span><br><span class="line">555</span><br><span class="line">556</span><br><span class="line">557</span><br><span class="line">558</span><br><span class="line">559</span><br><span class="line">560</span><br><span class="line">561</span><br><span class="line">562</span><br><span class="line">563</span><br><span class="line">564</span><br><span class="line">565</span><br><span class="line">566</span><br><span class="line">567</span><br><span class="line">568</span><br><span class="line">569</span><br><span class="line">570</span><br><span class="line">571</span><br><span class="line">572</span><br><span class="line">573</span><br><span class="line">574</span><br><span class="line">575</span><br><span class="line">576</span><br><span class="line">577</span><br><span class="line">578</span><br><span class="line">579</span><br><span class="line">580</span><br><span class="line">581</span><br><span class="line">582</span><br><span class="line">583</span><br><span class="line">584</span><br><span class="line">585</span><br><span class="line">586</span><br><span class="line">587</span><br><span class="line">588</span><br><span class="line">589</span><br><span class="line">590</span><br><span class="line">591</span><br><span class="line">592</span><br><span class="line">593</span><br><span class="line">594</span><br><span class="line">595</span><br><span class="line">596</span><br><span class="line">597</span><br><span class="line">598</span><br><span class="line">599</span><br><span class="line">600</span><br><span class="line">601</span><br><span class="line">602</span><br><span class="line">603</span><br><span class="line">604</span><br><span class="line">605</span><br><span class="line">606</span><br><span class="line">607</span><br><span class="line">608</span><br><span class="line">609</span><br><span class="line">610</span><br><span class="line">611</span><br><span class="line">612</span><br><span class="line">613</span><br><span class="line">614</span><br><span class="line">615</span><br><span class="line">616</span><br><span class="line">617</span><br><span class="line">618</span><br><span class="line">619</span><br><span class="line">620</span><br><span class="line">621</span><br><span class="line">622</span><br><span class="line">623</span><br><span class="line">624</span><br><span class="line">625</span><br><span class="line">626</span><br><span class="line">627</span><br><span class="line">628</span><br><span class="line">629</span><br><span class="line">630</span><br><span class="line">631</span><br><span class="line">632</span><br><span class="line">633</span><br><span class="line">634</span><br><span class="line">635</span><br><span class="line">636</span><br><span class="line">637</span><br><span class="line">638</span><br><span class="line">639</span><br><span class="line">640</span><br><span class="line">641</span><br><span class="line">642</span><br><span class="line">643</span><br><span class="line">644</span><br><span class="line">645</span><br><span class="line">646</span><br><span class="line">647</span><br><span class="line">648</span><br><span class="line">649</span><br><span class="line">650</span><br><span class="line">651</span><br><span class="line">652</span><br><span class="line">653</span><br><span class="line">654</span><br><span class="line">655</span><br><span class="line">656</span><br><span class="line">657</span><br><span class="line">658</span><br><span class="line">659</span><br><span class="line">660</span><br><span class="line">661</span><br><span class="line">662</span><br><span class="line">663</span><br><span class="line">664</span><br><span class="line">665</span><br><span class="line">666</span><br><span class="line">667</span><br><span class="line">668</span><br><span class="line">669</span><br><span class="line">670</span><br><span class="line">671</span><br><span class="line">672</span><br><span class="line">673</span><br><span class="line">674</span><br><span class="line">675</span><br><span class="line">676</span><br><span class="line">677</span><br><span class="line">678</span><br><span class="line">679</span><br><span class="line">680</span><br><span class="line">681</span><br><span class="line">682</span><br><span class="line">683</span><br><span class="line">684</span><br><span class="line">685</span><br><span class="line">686</span><br><span class="line">687</span><br><span class="line">688</span><br><span class="line">689</span><br><span class="line">690</span><br><span class="line">691</span><br><span class="line">692</span><br><span class="line">693</span><br><span class="line">694</span><br><span class="line">695</span><br><span class="line">696</span><br><span class="line">697</span><br><span class="line">698</span><br><span class="line">699</span><br><span class="line">700</span><br><span class="line">701</span><br><span class="line">702</span><br><span class="line">703</span><br><span class="line">704</span><br><span class="line">705</span><br><span class="line">706</span><br><span class="line">707</span><br><span class="line">708</span><br><span class="line">709</span><br><span class="line">710</span><br><span class="line">711</span><br><span class="line">712</span><br><span class="line">713</span><br><span class="line">714</span><br><span class="line">715</span><br><span class="line">716</span><br><span class="line">717</span><br><span class="line">718</span><br><span class="line">719</span><br><span class="line">720</span><br><span class="line">721</span><br><span class="line">722</span><br><span class="line">723</span><br><span class="line">724</span><br><span class="line">725</span><br><span class="line">726</span><br><span class="line">727</span><br><span class="line">728</span><br><span class="line">729</span><br><span class="line">730</span><br><span class="line">731</span><br><span class="line">732</span><br><span class="line">733</span><br><span class="line">734</span><br><span class="line">735</span><br><span class="line">736</span><br><span class="line">737</span><br><span class="line">738</span><br><span class="line">739</span><br><span class="line">740</span><br><span class="line">741</span><br><span class="line">742</span><br><span class="line">743</span><br><span class="line">744</span><br><span class="line">745</span><br><span class="line">746</span><br><span class="line">747</span><br><span class="line">748</span><br><span class="line">749</span><br><span class="line">750</span><br><span class="line">751</span><br><span class="line">752</span><br><span class="line">753</span><br><span class="line">754</span><br><span class="line">755</span><br><span class="line">756</span><br><span class="line">757</span><br><span class="line">758</span><br><span class="line">759</span><br><span class="line">760</span><br><span class="line">761</span><br><span class="line">762</span><br><span class="line">763</span><br><span class="line">764</span><br><span class="line">765</span><br><span class="line">766</span><br><span class="line">767</span><br><span class="line">768</span><br><span class="line">769</span><br><span class="line">770</span><br><span class="line">771</span><br><span class="line">772</span><br><span class="line">773</span><br><span class="line">774</span><br><span class="line">775</span><br><span class="line">776</span><br><span class="line">777</span><br><span class="line">778</span><br><span class="line">779</span><br><span class="line">780</span><br><span class="line">781</span><br><span class="line">782</span><br><span class="line">783</span><br><span class="line">784</span><br><span class="line">785</span><br><span class="line">786</span><br><span class="line">787</span><br><span class="line">788</span><br><span class="line">789</span><br><span class="line">790</span><br><span class="line">791</span><br><span class="line">792</span><br><span class="line">793</span><br><span class="line">794</span><br><span class="line">795</span><br><span class="line">796</span><br><span class="line">797</span><br><span class="line">798</span><br><span class="line">799</span><br><span class="line">800</span><br><span class="line">801</span><br><span class="line">802</span><br><span class="line">803</span><br><span class="line">804</span><br><span class="line">805</span><br><span class="line">806</span><br><span class="line">807</span><br><span class="line">808</span><br><span class="line">809</span><br><span class="line">810</span><br><span class="line">811</span><br><span class="line">812</span><br><span class="line">813</span><br><span class="line">814</span><br><span class="line">815</span><br><span class="line">816</span><br><span class="line">817</span><br><span class="line">818</span><br><span class="line">819</span><br><span class="line">820</span><br><span class="line">821</span><br><span class="line">822</span><br><span class="line">823</span><br><span class="line">824</span><br><span class="line">825</span><br><span class="line">826</span><br><span class="line">827</span><br><span class="line">828</span><br><span class="line">829</span><br><span class="line">830</span><br><span class="line">831</span><br><span class="line">832</span><br><span class="line">833</span><br><span class="line">834</span><br><span class="line">835</span><br><span class="line">836</span><br><span class="line">837</span><br><span class="line">838</span><br><span class="line">839</span><br><span class="line">840</span><br><span class="line">841</span><br><span class="line">842</span><br><span class="line">843</span><br><span class="line">844</span><br><span class="line">845</span><br><span class="line">846</span><br><span class="line">847</span><br><span class="line">848</span><br><span class="line">849</span><br><span class="line">850</span><br><span class="line">851</span><br><span class="line">852</span><br><span class="line">853</span><br><span class="line">854</span><br><span class="line">855</span><br><span class="line">856</span><br><span class="line">857</span><br><span class="line">858</span><br><span class="line">859</span><br><span class="line">860</span><br><span class="line">861</span><br><span class="line">862</span><br><span class="line">863</span><br><span class="line">864</span><br><span class="line">865</span><br><span class="line">866</span><br><span class="line">867</span><br><span class="line">868</span><br><span class="line">869</span><br><span class="line">870</span><br><span class="line">871</span><br><span class="line">872</span><br><span class="line">873</span><br><span class="line">874</span><br><span class="line">875</span><br><span class="line">876</span><br><span class="line">877</span><br><span class="line">878</span><br><span class="line">879</span><br><span class="line">880</span><br><span class="line">881</span><br><span class="line">882</span><br><span class="line">883</span><br><span class="line">884</span><br><span class="line">885</span><br><span class="line">886</span><br><span class="line">887</span><br><span class="line">888</span><br><span class="line">889</span><br><span class="line">890</span><br><span class="line">891</span><br><span class="line">892</span><br><span class="line">893</span><br><span class="line">894</span><br><span class="line">895</span><br><span class="line">896</span><br><span class="line">897</span><br><span class="line">898</span><br><span class="line">899</span><br><span class="line">900</span><br><span class="line">901</span><br><span class="line">902</span><br><span class="line">903</span><br><span class="line">904</span><br><span class="line">905</span><br><span class="line">906</span><br><span class="line">907</span><br><span class="line">908</span><br><span class="line">909</span><br><span class="line">910</span><br><span class="line">911</span><br><span class="line">912</span><br><span class="line">913</span><br><span class="line">914</span><br><span class="line">915</span><br><span class="line">916</span><br><span class="line">917</span><br><span class="line">918</span><br><span class="line">919</span><br><span class="line">920</span><br><span class="line">921</span><br><span class="line">922</span><br><span class="line">923</span><br><span class="line">924</span><br><span class="line">925</span><br><span class="line">926</span><br><span class="line">927</span><br><span class="line">928</span><br><span class="line">929</span><br><span class="line">930</span><br><span class="line">931</span><br><span class="line">932</span><br><span class="line">933</span><br><span class="line">934</span><br><span class="line">935</span><br><span class="line">936</span><br><span class="line">937</span><br><span class="line">938</span><br><span class="line">939</span><br><span class="line">940</span><br><span class="line">941</span><br><span class="line">942</span><br><span class="line">943</span><br><span class="line">944</span><br><span class="line">945</span><br><span class="line">946</span><br><span class="line">947</span><br><span class="line">948</span><br><span class="line">949</span><br><span class="line">950</span><br><span class="line">951</span><br><span class="line">952</span><br><span class="line">953</span><br><span class="line">954</span><br><span class="line">955</span><br><span class="line">956</span><br><span class="line">957</span><br><span class="line">958</span><br><span class="line">959</span><br><span class="line">960</span><br><span class="line">961</span><br><span class="line">962</span><br><span class="line">963</span><br><span class="line">964</span><br><span class="line">965</span><br><span class="line">966</span><br><span class="line">967</span><br><span class="line">968</span><br><span class="line">969</span><br><span class="line">970</span><br><span class="line">971</span><br><span class="line">972</span><br><span class="line">973</span><br><span class="line">974</span><br><span class="line">975</span><br><span class="line">976</span><br><span class="line">977</span><br><span class="line">978</span><br><span class="line">979</span><br><span class="line">980</span><br><span class="line">981</span><br><span class="line">982</span><br><span class="line">983</span><br><span class="line">984</span><br><span class="line">985</span><br><span class="line">986</span><br><span class="line">987</span><br><span class="line">988</span><br><span class="line">989</span><br><span class="line">990</span><br><span class="line">991</span><br><span class="line">992</span><br><span class="line">993</span><br><span class="line">994</span><br><span class="line">995</span><br><span class="line">996</span><br><span class="line">997</span><br><span class="line">998</span><br><span class="line">999</span><br><span class="line">1000</span><br><span class="line">1001</span><br><span class="line">1002</span><br><span class="line">1003</span><br><span class="line">1004</span><br><span class="line">1005</span><br><span class="line">1006</span><br><span class="line">1007</span><br><span class="line">1008</span><br><span class="line">1009</span><br><span class="line">1010</span><br><span class="line">1011</span><br><span class="line">1012</span><br><span class="line">1013</span><br><span class="line">1014</span><br><span class="line">1015</span><br><span class="line">1016</span><br><span class="line">1017</span><br><span class="line">1018</span><br><span class="line">1019</span><br><span class="line">1020</span><br><span class="line">1021</span><br><span class="line">1022</span><br><span class="line">1023</span><br><span class="line">1024</span><br><span class="line">1025</span><br><span class="line">1026</span><br><span class="line">1027</span><br><span class="line">1028</span><br><span class="line">1029</span><br><span class="line">1030</span><br><span class="line">1031</span><br><span class="line">1032</span><br><span class="line">1033</span><br><span class="line">1034</span><br><span class="line">1035</span><br><span class="line">1036</span><br><span class="line">1037</span><br><span class="line">1038</span><br><span class="line">1039</span><br><span class="line">1040</span><br><span class="line">1041</span><br><span class="line">1042</span><br><span class="line">1043</span><br><span class="line">1044</span><br><span class="line">1045</span><br><span class="line">1046</span><br><span class="line">1047</span><br><span class="line">1048</span><br><span class="line">1049</span><br><span class="line">1050</span><br><span class="line">1051</span><br><span class="line">1052</span><br><span class="line">1053</span><br><span class="line">1054</span><br><span class="line">1055</span><br><span class="line">1056</span><br><span class="line">1057</span><br><span class="line">1058</span><br><span class="line">1059</span><br><span class="line">1060</span><br><span class="line">1061</span><br><span class="line">1062</span><br><span class="line">1063</span><br><span class="line">1064</span><br><span class="line">1065</span><br><span class="line">1066</span><br><span class="line">1067</span><br><span class="line">1068</span><br><span class="line">1069</span><br><span class="line">1070</span><br><span class="line">1071</span><br><span class="line">1072</span><br><span class="line">1073</span><br><span class="line">1074</span><br><span class="line">1075</span><br><span class="line">1076</span><br><span class="line">1077</span><br><span class="line">1078</span><br><span class="line">1079</span><br><span class="line">1080</span><br><span class="line">1081</span><br><span class="line">1082</span><br><span class="line">1083</span><br><span class="line">1084</span><br><span class="line">1085</span><br><span class="line">1086</span><br><span class="line">1087</span><br><span class="line">1088</span><br><span class="line">1089</span><br><span class="line">1090</span><br><span class="line">1091</span><br><span class="line">1092</span><br><span class="line">1093</span><br><span class="line">1094</span><br><span class="line">1095</span><br><span class="line">1096</span><br><span class="line">1097</span><br><span class="line">1098</span><br><span class="line">1099</span><br><span class="line">1100</span><br><span class="line">1101</span><br><span class="line">1102</span><br><span class="line">1103</span><br></pre></td><td class="code"><pre><span class="line">// https://juejin.im/post/5cef46226fb9a07eaf2b7516</span><br><span class="line">1.</span><br><span class="line">const isType = type =&gt; target =&gt; `[object $&#123;type&#125;]` === Object.prototype.toString.call(target)</span><br><span class="line"></span><br><span class="line">const selfIsArray = isType(&apos;Array&apos;)</span><br><span class="line"></span><br><span class="line">Array.selfIsArray || (Object.defineProperty(Array, &apos;selfIsArray&apos;, &#123;</span><br><span class="line">  value: selfIsArray,</span><br><span class="line">  enumerable: false,</span><br><span class="line">  configurable: true,</span><br><span class="line">  writable: false</span><br><span class="line">&#125;))</span><br><span class="line"></span><br><span class="line">console.log(selfIsArray([])) // true</span><br><span class="line"></span><br><span class="line">2.</span><br><span class="line">// 循环实现map</span><br><span class="line">const selfMap = function(fn, context) &#123;</span><br><span class="line">  let arr = Array.prototype.slice.call(this)</span><br><span class="line">  let mappedArr = [];</span><br><span class="line"></span><br><span class="line">  for (let i = 0, len = arr.length; i &lt; len; i++) &#123;</span><br><span class="line">    // 判断稀疏数组的情况</span><br><span class="line">    if (!arr.hasOwnProperty(i)) continue;</span><br><span class="line">    mappedArr[i] = fn.call(context, arr[i], i, this)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  return mappedArr</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// reduce实现map</span><br><span class="line">// 由于 reduce 会跳过空单元数组，所以这个 polyfill 无法处理空单元数组</span><br><span class="line">const selfMap2 = function(fn, context) &#123;</span><br><span class="line">  let arr = Array.prototype.slice.call(this)</span><br><span class="line"></span><br><span class="line">  return arr.reduce((pre, cur, index) =&gt; [...pre, fn.call(context, cur, index, this)], [])</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Array.prototype.selfMap || (Object.defineProperty(Array.prototype, &apos;selfMap&apos;, &#123;</span><br><span class="line">    value: selfMap,</span><br><span class="line">    enumerable: false,</span><br><span class="line">    configurable: true,</span><br><span class="line">    writable: true</span><br><span class="line">&#125;))</span><br><span class="line"></span><br><span class="line">Array.prototype.selfMap2 || (Object.defineProperty(Array.prototype, &apos;selfMap2&apos;, &#123;</span><br><span class="line">    value: selfMap2,</span><br><span class="line">    enumerable: false,</span><br><span class="line">    configurable: true,</span><br><span class="line">    writable: true</span><br><span class="line">&#125;))</span><br><span class="line"></span><br><span class="line">let arr = [&apos;z&apos;, &apos;h&apos;, &apos;l&apos;]</span><br><span class="line">console.log(arr.selfMap(item =&gt; item + &apos;1&apos;))</span><br><span class="line"></span><br><span class="line">3.</span><br><span class="line">// 循环实现filter</span><br><span class="line">const selfFilter = function(fn, context) &#123;</span><br><span class="line">  let arr = Array.prototype.slice.call(this)</span><br><span class="line">  let filteredArr = []</span><br><span class="line"></span><br><span class="line">  for (let i = 0, len = arr.length; i &lt; len; i++) &#123;</span><br><span class="line">    if (!arr.hasOwnProperty(i)) continue</span><br><span class="line">    fn.call(context, arr[i], i, this) &amp;&amp; filteredArr.push(arr[i])</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  return filteredArr</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// reduce实现filter</span><br><span class="line">const selfFilter2 = function(fn, context) &#123;</span><br><span class="line">  return this.reduce((pre, cur, index) =&gt; &#123;</span><br><span class="line">    return fn.call(context, cur, index, this) ? [...pre, cur] : [...pre]</span><br><span class="line">  &#125;, [])</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Array.prototype.selfFilter || (Object.defineProperty(Array.prototype, &apos;selfFilter&apos;, &#123;</span><br><span class="line">    value: selfFilter,</span><br><span class="line">    enumerable: false,</span><br><span class="line">    configurable: true,</span><br><span class="line">    writable: true</span><br><span class="line">&#125;))</span><br><span class="line"></span><br><span class="line">Array.prototype.selfFilter2 || (Object.defineProperty(Array.prototype, &apos;selfFilter2&apos;, &#123;</span><br><span class="line">    value: selfFilter2,</span><br><span class="line">    enumerable: false,</span><br><span class="line">    configurable: true,</span><br><span class="line">    writable: true</span><br><span class="line">&#125;))</span><br><span class="line"></span><br><span class="line">let arr = [1, 2, 3]</span><br><span class="line">console.log(arr.selfFilter(item =&gt; item === 2))</span><br><span class="line">// 当给 filter 函数传入第二个参数时,第一个参数不能为箭头函数,否则为词法绑定，第二个参数会失效，其他迭代方法同理</span><br><span class="line">console.log(arr.selfFilter2(function(item) &#123;</span><br><span class="line">  return item === 2</span><br><span class="line">&#125;, [&apos;a&apos;, &apos;b&apos;, &apos;c&apos;]))</span><br><span class="line"></span><br><span class="line">4.</span><br><span class="line">// ES5循环实现 some 方法</span><br><span class="line">const selfSome = function (fn, context) &#123;</span><br><span class="line">    let arr = Array.prototype.slice.call(this)</span><br><span class="line">    // 空数组直接返回 false，数组的 every 方法则相反返回 true</span><br><span class="line">    if(!arr.length) return false</span><br><span class="line">    for (let i = 0; i &lt; arr.length; i++) &#123;</span><br><span class="line">        if(!arr.hasOwnProperty(i)) continue;</span><br><span class="line">        let res = fn.call(context,arr[i],i,this)</span><br><span class="line">        if(res)return true</span><br><span class="line">    &#125;</span><br><span class="line">    return false</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Array.prototype.selfSome ||(Object.defineProperty(Array.prototype, &apos;selfSome&apos;, &#123;</span><br><span class="line">    value: selfSome,</span><br><span class="line">    enumerable: false,</span><br><span class="line">    configurable: true,</span><br><span class="line">    writable: true</span><br><span class="line">&#125;))</span><br><span class="line"></span><br><span class="line">let arr = [1, 2, 3, 4, 5]</span><br><span class="line">console.log(arr.selfSome(item =&gt; item === 2))</span><br><span class="line"></span><br><span class="line">5.</span><br><span class="line">// ES5循环实现reduce</span><br><span class="line">Array.prototype.selfReduce = function (fn, initialValue) &#123;</span><br><span class="line">    let arr = Array.prototype.slice.call(this)</span><br><span class="line">    let res</span><br><span class="line">    let startIndex</span><br><span class="line">    if (initialValue === undefined) &#123;</span><br><span class="line">        // 找到第一个非空单元（真实）的元素和下标</span><br><span class="line">        for (let i = 0; i &lt; arr.length; i++) &#123;</span><br><span class="line">            if (!arr.hasOwnProperty(i)) continue</span><br><span class="line">            startIndex = i</span><br><span class="line">            res = arr[i]</span><br><span class="line">            break</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        res = initialValue</span><br><span class="line">    &#125;</span><br><span class="line">    // 遍历的起点为上一步中找到的真实元素后面一个真实元素</span><br><span class="line">    // 每次遍历会跳过空单元的元素</span><br><span class="line">    for (let i = ++startIndex || 0; i &lt; arr.length; i++) &#123;</span><br><span class="line">        if (!arr.hasOwnProperty(i)) continue</span><br><span class="line">        res = fn.call(null, res, arr[i], i, this)</span><br><span class="line">    &#125;</span><br><span class="line">    return res</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Array.prototype.selfReduce || (Object.defineProperty(Array.prototype, &apos;selfReduce&apos;, &#123;</span><br><span class="line">    value: selfReduce,</span><br><span class="line">    enumerable: false,</span><br><span class="line">    configurable: true,</span><br><span class="line">    writable: true</span><br><span class="line">&#125;))</span><br><span class="line"></span><br><span class="line">let arr = [1, 2, 3, 4, 5]</span><br><span class="line">console.log(arr.selfReduce((acc, cur) =&gt; acc + cur))</span><br><span class="line">console.log(arr.reduce((acc, cur) =&gt; acc + cur))</span><br><span class="line"></span><br><span class="line">6.</span><br><span class="line">// reduce实现 Array.prototype.flat，数组扁平化</span><br><span class="line">const selfFlat = function (depth = 1) &#123;</span><br><span class="line">    let arr = Array.prototype.slice.call(this)</span><br><span class="line">    if (depth === 0) return arr</span><br><span class="line">    return arr.reduce((pre, cur) =&gt; &#123;</span><br><span class="line">        if (Array.isArray(cur)) &#123;</span><br><span class="line">            // 需要用 call 绑定 this 值，否则会指向 window</span><br><span class="line">            return [...pre, ...selfFlat.call(cur, depth - 1)]</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            return [...pre, cur]</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;, [])</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Array.prototype.selfFlat || (Object.defineProperty(Array.prototype, &apos;selfFlat&apos;, &#123;</span><br><span class="line">    value: selfFlat,</span><br><span class="line">    enumerable: false,</span><br><span class="line">    configurable: true,</span><br><span class="line">    writable: true</span><br><span class="line">&#125;))</span><br><span class="line"></span><br><span class="line">let arr = [1, 2, [3, 4, [5, 6, 7, 8], 9], 10, 11, 12, [13, 14]]</span><br><span class="line">console.log(arr.selfFlat()) // 传入 Inifity 会将传入的数组变成一个一维数组</span><br><span class="line"></span><br><span class="line">7.</span><br><span class="line">// 寄生组合式继承 + 构造函数之间的继承</span><br><span class="line">function inherit(subType, superType) &#123;</span><br><span class="line">  // 由于JavaScript引用类型和函数按值传递的特性，不能改变 subType 的引用地址</span><br><span class="line">  subType.prototype = Object.create(superType.prototype, &#123;</span><br><span class="line">    constructor: &#123;</span><br><span class="line">      enumerable: false,</span><br><span class="line">      configurable: true,</span><br><span class="line">      writable: true,</span><br><span class="line">      // 指向子类，和默认的继承行为保持一致</span><br><span class="line">      value: subType</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;)</span><br><span class="line"></span><br><span class="line">  //子构造函数继承父构造函数(子类继承父类的静态方法和静态属性)</span><br><span class="line">  Object.setPrototypeOf(subType, superType)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">8.</span><br><span class="line">https://github.com/yeyan1996/JavaScript/blob/master/curry.js</span><br><span class="line"></span><br><span class="line">9.</span><br><span class="line">/**</span><br><span class="line"> * @description 偏函数（创建已经设置好一个或多个参数的函数,并且添加了占位符功能）</span><br><span class="line"> * @param &#123;Function&#125; func -部分求值的函数</span><br><span class="line"> * @param &#123;...*&#125; [args] -部分求值的参数</span><br><span class="line"> * @return &#123;Function&#125; -部分求值后的函数</span><br><span class="line"> **/</span><br><span class="line"></span><br><span class="line">const partialFunc = (func, ...args) =&gt; &#123;</span><br><span class="line">    let placeholderNum = 0</span><br><span class="line">    return (...args2) =&gt; &#123;</span><br><span class="line">        args2.forEach(arg =&gt; &#123;</span><br><span class="line">            let index = args.findIndex(item =&gt; item === &quot;_&quot;)</span><br><span class="line">            if (index &lt; 0) return</span><br><span class="line">            args[index] = arg</span><br><span class="line">            placeholderNum++</span><br><span class="line">        &#125;)</span><br><span class="line">        if (placeholderNum &lt; args2.length) &#123;</span><br><span class="line">            args2 = args2.slice(placeholderNum, args2.length)</span><br><span class="line">        &#125;</span><br><span class="line">        return func.apply(this, [...args, ...args2])</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">const display = (a, b, c, d, e, f, g, h) =&gt; [a, b, c, d, e, f, g, h];</span><br><span class="line"></span><br><span class="line">let partialDisplay = partialFunc(display, 1, 2)</span><br><span class="line">console.log(&quot;partialFunc&quot;, partialDisplay(3, 4, 5, 6, 7, 8))</span><br><span class="line"></span><br><span class="line">let partialDisplay2 = partialFunc(display, &apos;_&apos;, 2, &apos;_&apos;) // 使用占位符</span><br><span class="line">console.log(&apos;partialFunc2&apos;, partialDisplay2(1, 3, 4, 5, 6, 7, 8))</span><br><span class="line"></span><br><span class="line">10.</span><br><span class="line">const speed = function (fn, num) &#123;</span><br><span class="line">    console.time(&apos;time&apos;)</span><br><span class="line">    let value = fn(num)</span><br><span class="line">    console.timeEnd(&apos;time&apos;)</span><br><span class="line">    console.log(`返回值:$&#123;value&#125;`)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * @description 斐波那契数列</span><br><span class="line"> * @param &#123;number&#125; n -第几个位置</span><br><span class="line"> * @return &#123;number&#125; 参数对应在数列中的数字</span><br><span class="line"> **/</span><br><span class="line">let fibonacci = function (n) &#123;</span><br><span class="line">    if (n &lt; 1) return 0</span><br><span class="line">    if (n === 1 || n === 2) return 1</span><br><span class="line">    return fibonacci(n - 1) + fibonacci(n - 2)</span><br><span class="line">&#125;</span><br><span class="line">speed(fibonacci, 35) // 简单递归实现 缺点：达到一定数量级时变的很慢 耗性能</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">// 函数记忆</span><br><span class="line">const memory = function (fn) &#123;</span><br><span class="line">    let obj = &#123;&#125;</span><br><span class="line">    return function (n) &#123;</span><br><span class="line">        if (obj[n] === undefined) obj[n] = fn(n)</span><br><span class="line">        return obj[n]</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">fibonacci = memory(fibonacci)</span><br><span class="line">speed(fibonacci, 35) // 利用闭包特性</span><br><span class="line"></span><br><span class="line">// 动态规划方案</span><br><span class="line">function fibonacci_DP_1(n) &#123;</span><br><span class="line">  // 用数组来存取每一次产生子问题的结果</span><br><span class="line">  if (n &lt;= 0) return 0</span><br><span class="line">  if (n === 1) return 1</span><br><span class="line">  var arr = [0, 1]</span><br><span class="line">  for (var i = 2; i &lt;= n; i++) &#123;</span><br><span class="line">    arr[i] = arr[i - 1] + arr[i - 2]</span><br><span class="line">  &#125;</span><br><span class="line">  return arr[n]</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function fibonacci_DP_2(n) &#123;</span><br><span class="line">  // 局部变量来实现可以省下内存空间</span><br><span class="line">  if (n &lt;= 0) return 0</span><br><span class="line">  if (n === 1) return 1</span><br><span class="line">  var res, a = 0, b = 1</span><br><span class="line">  for (var i = 2; i &lt;= n; i++) &#123;</span><br><span class="line">    res = a + b;</span><br><span class="line">    a = b;</span><br><span class="line">    b = res;</span><br><span class="line">  &#125;</span><br><span class="line">  return res</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function fibonacci_DP_3(n) &#123;</span><br><span class="line">  // 最优解版本</span><br><span class="line">  if (n &lt;= 0) return 0</span><br><span class="line">  if (n &lt;= 1) return 1</span><br><span class="line">  var a = 0, b = 1</span><br><span class="line">  for (var i = 2; i &lt;= n; i++) &#123;</span><br><span class="line">    b = a + b</span><br><span class="line">    a = b - a</span><br><span class="line">  &#125;</span><br><span class="line">  return b</span><br><span class="line">&#125;</span><br><span class="line">speed(fibonacci_DP_3, 35)</span><br><span class="line"></span><br><span class="line">11.</span><br><span class="line">// 求最长公共子串的动态规划算法</span><br><span class="line"></span><br><span class="line">12.</span><br><span class="line">// 0-1背包问题</span><br><span class="line"></span><br><span class="line">13.</span><br><span class="line">// 实现函数 bind 方法</span><br><span class="line">// 会创建一个新函数。当这个新函数被调用时，bind() 的第一个参数将作为它运行时的 this，之后的一序列参数将会在传递的实参前传入作为它的参数</span><br><span class="line">const isComplexDataType = obj =&gt; obj !== null &amp;&amp; (typeof obj === &apos;function&apos; || typeof obj === &apos;object&apos;)</span><br><span class="line"></span><br><span class="line">const selfBind = function (bindTarget, ...args1) &#123;</span><br><span class="line">  if (typeof this !== &apos;function&apos;) throw new TypeError(&apos;Bind must be called on a function&apos;)</span><br><span class="line"></span><br><span class="line">  const originFunc = this</span><br><span class="line">  const boundFunc = function (...args2) &#123;</span><br><span class="line">    // 使用 new 关键字调用返回新对象</span><br><span class="line">    if (new.target) &#123;</span><br><span class="line">      const res = originFunc.call(this, ...args1, ...args2)</span><br><span class="line">      // 如果构造函数返回一个对象则返回这个对象</span><br><span class="line">      if (isComplexDataType(res)) return res</span><br><span class="line">      // 否则返回新建的对象</span><br><span class="line">      return this</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">      originFunc.call(bindTarget, ...args1, ...args2)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  // 真正的 bind 创建的函数是没有 prototype 的，取而代之有个 [[TargetFunction]] 保存 bind 前的函数</span><br><span class="line">  // 使用 new 会将创建的对象的 __proto__ 连接 [[TargetFunction] prototype (非箭头函数)</span><br><span class="line">  // 这里给 bind 后的函数手动设置一个 prototype 属性，模拟这个行为</span><br><span class="line">  // 箭头函数则没有 prototype</span><br><span class="line">  if (originFunc.prototype) boundFunc.prototype = originFunc.prototype</span><br><span class="line"></span><br><span class="line">  // 定义绑定后函数的长度和名字</span><br><span class="line">  const desc = Object.getOwnPropertyDescriptors(originFunc)</span><br><span class="line">  Object.defineProperties(boundFunc, &#123;</span><br><span class="line">    length: desc.length,</span><br><span class="line">    name: Object.assign(desc.name, &#123;</span><br><span class="line">      value: `bound $&#123;desc.name.value&#125;`</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;)</span><br><span class="line"></span><br><span class="line">  return boundFunc</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">14.</span><br><span class="line">// 实现函数 call 方法</span><br><span class="line">// call 核心：</span><br><span class="line">// 1、将函数设置为对象的属性</span><br><span class="line">// 2、执行&amp;删除这个函数</span><br><span class="line">// 3、指定 this 到函数并传入给定参数执行函数</span><br><span class="line">// 4、如果不传入参数，默认指向为 window</span><br><span class="line">Function.prototype.selfCall = function (context = window, ...args) &#123;</span><br><span class="line">  let func = this // 首先要获取调用call的函数，用this可以获取</span><br><span class="line">  if (typeof func !== &apos;function&apos;) throw new TypeError(&apos;this is not function&apos;)</span><br><span class="line">  let caller = Symbol(&apos;caller&apos;)</span><br><span class="line">  context[caller] = func // 创建一个caller属性，值设置为需要调用的函数</span><br><span class="line">  let res = context[caller](...args)</span><br><span class="line">  delete context[caller]</span><br><span class="line">  return res</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">let foo = &#123;</span><br><span class="line">  value: 1</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function bar(name, age) &#123;</span><br><span class="line">  console.log(name)</span><br><span class="line">  console.log(age)</span><br><span class="line">  console.log(this.value);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">bar.selfCall(foo, &apos;black&apos;, &apos;18&apos;) // black 18 1</span><br><span class="line"></span><br><span class="line">// 实现函数 apply 方法</span><br><span class="line">Function.prototype.selfApply = function (context = window) &#123;</span><br><span class="line">  if (typeof this !== &apos;function&apos;) throw new TypeError(&apos;this is not function&apos;)</span><br><span class="line">  context.fn = this</span><br><span class="line">  let res</span><br><span class="line">  // 判断是否有第二个参数</span><br><span class="line">  if (arguments[1]) &#123;</span><br><span class="line">    res = context.fn(...arguments[1])</span><br><span class="line">  &#125; else &#123;</span><br><span class="line">    res = context.fn()</span><br><span class="line">  &#125;</span><br><span class="line">  delete context.fn</span><br><span class="line">  return res</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">15.</span><br><span class="line">// 简易的 CO 模块</span><br><span class="line"></span><br><span class="line">16.</span><br><span class="line">// 函数防抖</span><br><span class="line">// 需要处理3个问题：</span><br><span class="line">// 1、this 指向</span><br><span class="line">// 2、event 对象</span><br><span class="line">// 3、返回值</span><br><span class="line">// 4、是否立刻执行</span><br><span class="line">const debounce = (fn, delay = 1000, options = &#123;</span><br><span class="line">  leading: true, // 是否立刻执行</span><br><span class="line">  context: null</span><br><span class="line">&#125;) =&gt; &#123;</span><br><span class="line">  let timer;</span><br><span class="line"></span><br><span class="line">  const _debounce = function (...args) &#123;</span><br><span class="line">    if (timer) clearTimeout(timer)</span><br><span class="line"></span><br><span class="line">    if (options.leading &amp;&amp; !timer) &#123;</span><br><span class="line">      timer = setTimeout(null, delay)</span><br><span class="line">      fn.apply(options.context, args)</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">      timer = setTimeout(() =&gt; &#123;</span><br><span class="line">        fn.apply(options.context, args)</span><br><span class="line">        timer = null</span><br><span class="line">      &#125;, delay)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  _debounce.cancel = function () &#123;</span><br><span class="line">    clearTimeout(timer)</span><br><span class="line">    timer = null</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  return _debounce</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">17.</span><br><span class="line">// 函数节流</span><br><span class="line">// leading 和 trailing 无法同时为 false</span><br><span class="line">const throttle = (fn, delay = 1000, options = &#123;</span><br><span class="line">  leading: true, // 是否立刻执行</span><br><span class="line">  trailing: false, // 是否在最后额外触发一次</span><br><span class="line">  context: null</span><br><span class="line">&#125;) =&gt; &#123;</span><br><span class="line">  let timer;</span><br><span class="line">  let startTime = Date.now();</span><br><span class="line"></span><br><span class="line">  let _throttle = function (...args) &#123;</span><br><span class="line">    let curTime = Date.now()</span><br><span class="line"></span><br><span class="line">    if (!options.leading) &#123;</span><br><span class="line">      if (timer) return</span><br><span class="line">      timer = setTimeout(() =&gt; &#123;</span><br><span class="line">        fn.apply(options.context, args)</span><br><span class="line">        timer = null</span><br><span class="line">      &#125;, delay)</span><br><span class="line">    &#125; else if (curTime - startTime &gt;= delay) &#123;</span><br><span class="line">      fn.apply(options.context, args)</span><br><span class="line">      startTime = curTime</span><br><span class="line">    &#125; else if (options.trailing) &#123;</span><br><span class="line">      clearTimeout(timer)</span><br><span class="line">      timer = setTimeout(() =&gt; &#123;</span><br><span class="line">        fn.apply(options.context, args)</span><br><span class="line">      &#125;, delay)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  // 闭包返回取消函数</span><br><span class="line">  _throttle.cancel = function () &#123;</span><br><span class="line">    startTime = 0</span><br><span class="line">    clearTimeout(timer)</span><br><span class="line">    timer = null</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  return _throttle</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// * 使用 Proxy 实现函数节流</span><br><span class="line">function proxy (func, time, options = &#123;</span><br><span class="line">  leading: false,</span><br><span class="line">  trailing: true,</span><br><span class="line">  context: null</span><br><span class="line">&#125;) &#123;</span><br><span class="line">  let timer;</span><br><span class="line">  let previous = new Date(0).getTime();</span><br><span class="line"></span><br><span class="line">  let handler = &#123;</span><br><span class="line">    apply(target, _, args) &#123;</span><br><span class="line">      // 和闭包实现核心逻辑相同</span><br><span class="line">      let now = new Date().getTime();</span><br><span class="line"></span><br><span class="line">      if (!options.leading) &#123;</span><br><span class="line">        if (timer) return;</span><br><span class="line">        timer = setTimeout(() =&gt; &#123;</span><br><span class="line">          timer = null;</span><br><span class="line">          Reflect.apply(func, options.context, args)</span><br><span class="line">        &#125;, time)</span><br><span class="line">      &#125; else if (now - previous &gt; time) &#123;</span><br><span class="line">        Reflect.apply(func, options.context, args)</span><br><span class="line">        previous = now</span><br><span class="line">      &#125; else if (options.trailing) &#123;</span><br><span class="line">        clearTimeout(timer)</span><br><span class="line">        timer = setTimeout(() =&gt; &#123;</span><br><span class="line">          Reflect.apply(func, options.context, args)</span><br><span class="line">        &#125;, time)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  return new Proxy(func, handler)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">18.</span><br><span class="line">// 图片懒加载</span><br><span class="line">// getBoundingClientRect() 实现</span><br><span class="line">let imgList = [...document.querySelectorAll(&apos;img&apos;)]</span><br><span class="line"></span><br><span class="line">let lazyLoad = (function () &#123;</span><br><span class="line">  let count = 0</span><br><span class="line"></span><br><span class="line">  return function () &#123;</span><br><span class="line">    let deleteIndexList = []</span><br><span class="line"></span><br><span class="line">    imgList.forEach((img, index) =&gt; &#123;</span><br><span class="line">      let rect = img.getBoundingClientRect()</span><br><span class="line"></span><br><span class="line">      if (rect.top &lt; window.innerHeight) &#123;</span><br><span class="line">        // 进入视口</span><br><span class="line">        img.src = img.dataset.src</span><br><span class="line">        // 加载成功后将图片添加到删除列表中</span><br><span class="line">        deleteIndexList.push(index)</span><br><span class="line">        count++</span><br><span class="line">        if (count === imgList.length) document.removeEventListener(&apos;scroll&apos;, lazyLoad)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;)</span><br><span class="line"></span><br><span class="line">    // 删除已经加载完毕的图片</span><br><span class="line">    imgList = imgList.filter((_, index) =&gt; !deleteIndexList.includes(index))</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)()</span><br><span class="line"></span><br><span class="line">lazyLoad = proxy(lazyLoad, 1000)</span><br><span class="line"></span><br><span class="line">lazyLoad() // 手动加载一次，否则首屏的图片不触发滚动无法加载</span><br><span class="line">document.addEventListener(&apos;scroll&apos;, lazyLoad)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">// IntersectionObserver 实现</span><br><span class="line">let lazyLoad = function () &#123;</span><br><span class="line">  let observer = new IntersectionObserver(entries =&gt; &#123;</span><br><span class="line">    // entries 存储着所有被观察元素的 intersectionObserverEntry 配置</span><br><span class="line">    entries.forEach(entry =&gt; &#123;</span><br><span class="line">      // 大于0表示进入视口</span><br><span class="line">      if (entry.intersectionRatio &gt; 0) &#123;</span><br><span class="line">        entry.target.src = entry.target.dataset.src</span><br><span class="line">        // 取消观察</span><br><span class="line">        observer.unobserve(entry.target)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;)</span><br><span class="line"></span><br><span class="line">  imgList.forEach(img =&gt; &#123;</span><br><span class="line">    observer.observe(img)</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">lazyLoad()</span><br><span class="line"></span><br><span class="line">19.</span><br><span class="line">// new 关键字</span><br><span class="line">// 1、创建了一个全新的对象</span><br><span class="line">// 2、使 this 指向新创建的对象</span><br><span class="line">// 3、它会被执行[[Prototype]]链接</span><br><span class="line">// 4、通过 new 创建的每个对象将最终被 [[Prototype]] 链接到这个函数的原型 prototype 对象上</span><br><span class="line">// 5、如果函数没有返回对象类型 Object (包含Functoin, Array, Date, RegExg, Error)，那么 new 表达式中的函数调用将返回该对象引用</span><br><span class="line">const selfNew = function (fn, ...args) &#123;</span><br><span class="line">  let instance = Object.create(fn.prototype) // __proto__</span><br><span class="line">  let res = fn.call(instance, ...args)</span><br><span class="line">  return isComplexDataType(res) ? res : instance</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function Person (name, sex) &#123;</span><br><span class="line">  this.name = name</span><br><span class="line">  this.sex = sex</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">console.log(new Person(&apos;ma&apos;, &apos;male&apos;))</span><br><span class="line">// equals to</span><br><span class="line">console.log(selfNew(Person, &apos;ma&apos;, &apos;male&apos;))</span><br><span class="line"></span><br><span class="line">20.</span><br><span class="line">// 实现 Object.assign</span><br><span class="line">&quot;use strict&quot; //启用严格模式在尝试给基本包装类型已定义的下标赋值的时候报错</span><br><span class="line"></span><br><span class="line">const selfAssign = function (target, ...source) &#123;</span><br><span class="line">  if (target == null) throw new TypeError(&apos;Cannot convert undefined or null to object&apos;)</span><br><span class="line"></span><br><span class="line">  return source.reduce((acc, cur) =&gt; &#123;</span><br><span class="line">    isComplexDataType(acc) || (acc = new Object(acc)); // 变成一个基本包装类型</span><br><span class="line"></span><br><span class="line">    if (cur == null) return acc; // source 为 null, undefined 时忽略</span><br><span class="line"></span><br><span class="line">    // 遍历出 Symbol 属性和可枚举属性</span><br><span class="line">    [...Object.keys(cur), ...Object.getOwnPropertySymbols(cur)].forEach(key =&gt; &#123;</span><br><span class="line">      acc[key] = cur[key]</span><br><span class="line">    &#125;)</span><br><span class="line"></span><br><span class="line">    return acc</span><br><span class="line">  &#125;, target)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Object.selfAssign || Object.defineProperty(Object, &apos;selfAssign&apos;, &#123;</span><br><span class="line">  value: selfAssign,</span><br><span class="line">  configurable: true,</span><br><span class="line">  enumerable: false,</span><br><span class="line">  writable: false</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">let target = &#123;</span><br><span class="line">  a: 1,</span><br><span class="line">  b: 1</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">let obj1 = &#123;</span><br><span class="line">  a: 2,</span><br><span class="line">  b: 2,</span><br><span class="line">  c: undefined</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">let obj2 = &#123;</span><br><span class="line">  a: 3,</span><br><span class="line">  b: 3,</span><br><span class="line">  [Symbol(&quot;a&quot;)]: 3,</span><br><span class="line">  d: null</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">console.log(Object.selfAssign(target, obj1, obj2))</span><br><span class="line">console.log(Object.selfAssign(&quot;abd&quot;, null, undefined))</span><br><span class="line"></span><br><span class="line">21.</span><br><span class="line">// instanceof</span><br><span class="line">const selfInstanceof = function (left, right) &#123;</span><br><span class="line">  let proto = Object.getPrototypeOf(left)</span><br><span class="line"></span><br><span class="line">  while (true) &#123;</span><br><span class="line">    if (proto == null) return false</span><br><span class="line">    if (proto === right.prototype) return true</span><br><span class="line">    proto = Object.getPrototypeOf(proto)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">console.log(selfInstanceof(&#123;&#125;, Array))</span><br><span class="line"></span><br><span class="line">22.</span><br><span class="line">// 洗牌算法</span><br><span class="line">// 通过洗牌算法可以达到真正的乱序，洗牌算法分为原地和非原地</span><br><span class="line">// 原地的洗牌算法，不需要声明额外的数组从而更加节约内存占用率，原理是依次遍历数组的元素，将当前元素和之后的所有元素中随机选取一个进行交换</span><br><span class="line">function shuffle (arr) &#123;</span><br><span class="line">  for (let i = 0; i &lt; arr.length; i++) &#123;</span><br><span class="line">    let randomIndex = i + Math.floor(Math.random() * (arr.length - i))</span><br><span class="line">    [arr[i], arr[randomIndex]] = [arr[randomIndex], arr[i]]</span><br><span class="line">  &#125;</span><br><span class="line">  return arr</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 新生成一个数组,随机从原数组中取出一个元素放入新数组</span><br><span class="line">function shuffle2 (arr) &#123;</span><br><span class="line">    let _arr = []</span><br><span class="line">    while (arr.length) &#123;</span><br><span class="line">      let randomIndex = Math.floor(Math.random() * (arr.length))</span><br><span class="line">      _arr.push(arr.splice(randomIndex, 1)[0])</span><br><span class="line">    &#125;</span><br><span class="line">    return _arr</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">23.</span><br><span class="line">// 单例模式</span><br><span class="line">// 通过 ES6 的 Proxy 拦截构造函数的执行方法来实现的单例模式</span><br><span class="line">function proxy (func) &#123;</span><br><span class="line">  let instance;</span><br><span class="line">  let handler = &#123;</span><br><span class="line">    construct(target, args) &#123;</span><br><span class="line">      if (!instance) &#123;</span><br><span class="line">        // 没有实例就创造一个实例</span><br><span class="line">        instance = Reflect.construct(func,args)</span><br><span class="line">      &#125;</span><br><span class="line">      // 无论如何都会返回一个实例(new关键字)</span><br><span class="line">      return instance</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  return new Proxy(func, handler)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function Person(name, age) &#123;</span><br><span class="line">  this.name = name</span><br><span class="line">  this.age = age</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">const SingletonPerson = proxy(Person)</span><br><span class="line"></span><br><span class="line">let person1 = new SingletonPerson(&apos;zhl&apos;, 22)</span><br><span class="line"></span><br><span class="line">let person2 = new SingletonPerson(&apos;cyw&apos;, 22)</span><br><span class="line"></span><br><span class="line">console.log(person1 === person2) // true</span><br><span class="line"></span><br><span class="line">24.</span><br><span class="line">// promisify</span><br><span class="line">// 使用 nodejs 运行以下代码</span><br><span class="line">// 适合err-first风格的异步操作(eg. nodejs)的 promisify 通用函数</span><br><span class="line">const fs = require(&quot;fs&quot;)</span><br><span class="line"></span><br><span class="line">function promisify(asyncFunc) &#123;</span><br><span class="line">  return function (...args) &#123;</span><br><span class="line">    return new Promise((resolve, reject) =&gt; &#123;</span><br><span class="line">      args.push(function callback(err, ...values) &#123;</span><br><span class="line">        if (err) return reject(err)</span><br><span class="line">        return resolve(...values)</span><br><span class="line">      &#125;);</span><br><span class="line"></span><br><span class="line">      asyncFunc.call(this, ...args);</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">const fsp = new Proxy(fs, &#123;</span><br><span class="line">  get(target, key) &#123;</span><br><span class="line">    return promisify(target[key])</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">async function generateCommit() &#123;</span><br><span class="line">  try &#123;</span><br><span class="line">    let data = await fsp.readFile(&apos;./promisify.js&apos;, &apos;utf-8&apos;)</span><br><span class="line">    data += `\n//我是注释`</span><br><span class="line">    await fsp.writeFile(&apos;./promisify.js&apos;, data)</span><br><span class="line">  &#125; catch (e) &#123;</span><br><span class="line">    console.log(e)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">generateCommit()</span><br><span class="line"></span><br><span class="line">25.</span><br><span class="line">// async/await 优雅处理方式</span><br><span class="line">async function errorCaptured(asyncFunc) &#123;</span><br><span class="line">    try &#123;</span><br><span class="line">        let res = await asyncFunc()</span><br><span class="line">        return [null,res]</span><br><span class="line">    &#125; catch (e) &#123;</span><br><span class="line">        return [e,null]</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">26.</span><br><span class="line">// 发布订阅EventEmitter</span><br><span class="line">class EventEmitter &#123;</span><br><span class="line">  constructor() &#123;</span><br><span class="line">    this.subs = &#123;&#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  on(event, cb) &#123;</span><br><span class="line">    (this.subs[event] || (this.subs[event] = [])).push(cb)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  trigger(event, ...args) &#123;</span><br><span class="line">    this.subs[event] &amp;&amp; this.subs[event].forEach(cb =&gt; &#123;</span><br><span class="line">      // cb.apply(this, ...args)</span><br><span class="line">      cb(...args)</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  once(event, onceCb) &#123;</span><br><span class="line">    const cb = (...args) &#123;</span><br><span class="line">      onceCb(...args)</span><br><span class="line">      this.off(event, onceCb)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    this.on(event, cb)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  off(event, offCb) &#123;</span><br><span class="line">    if (this.subs[event]) &#123;</span><br><span class="line">      const idx = this.subs[event].findIndex(cb =&gt; cb === offCb)</span><br><span class="line">      this.subs[event].splice(idx, 1)</span><br><span class="line">      if (!this.subs[event].length) delete this.subs[event]</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">let dep = new EventEmitter()</span><br><span class="line"></span><br><span class="line">let cb = function () &#123;</span><br><span class="line">    console.log(&apos;handleClick&apos;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">let cb2 = function () &#123;</span><br><span class="line">    console.log(&apos;handleMouseover&apos;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">console.group()</span><br><span class="line">dep.on(&apos;click&apos;, cb)</span><br><span class="line">dep.on(&apos;click&apos;,cb2)</span><br><span class="line">dep.trigger(&apos;click&apos;)</span><br><span class="line">console.groupEnd()</span><br><span class="line"></span><br><span class="line">console.group()</span><br><span class="line">dep.off(&apos;click&apos;, cb)</span><br><span class="line">dep.trigger(&apos;click&apos;)</span><br><span class="line">console.groupEnd()</span><br><span class="line"></span><br><span class="line">console.group()</span><br><span class="line">dep.once(&apos;mouseover&apos;, cb2)</span><br><span class="line">dep.trigger(&apos;mouseover&apos;)</span><br><span class="line">dep.trigger(&apos;mouseover&apos;)</span><br><span class="line">console.groupEnd()</span><br><span class="line"></span><br><span class="line">27.</span><br><span class="line">// 简单实现 JSON.stringify 方法</span><br><span class="line">const isString = value =&gt; typeof value === &apos;string&apos;</span><br><span class="line">const isSymbol = value =&gt; typeof value === &apos;symbol&apos;</span><br><span class="line">const isUndefined = value =&gt; typeof value === &apos;undefined&apos;</span><br><span class="line">const isDate = obj =&gt; Object.prototype.toString.call(obj) === &apos;[object Date]&apos;</span><br><span class="line">const isFunction = obj =&gt; Object.prototype.toString.call(obj) === &apos;[object Function]&apos;</span><br><span class="line">const isComplexDataType = value =&gt; (typeof value === &apos;object&apos; || typeof value === &apos;function&apos;) &amp;&amp; value !== null</span><br><span class="line">const isValidBasicDataType = value =&gt; value !== undefined &amp;&amp; !isSymbol(value) // 合法的基础类型</span><br><span class="line">const isValidObj = obj =&gt; Array.isArray(obj) || Object.prototype.toString.call(obj) === &apos;[object Object]&apos; // 合法的复杂类型(对象)</span><br><span class="line">const isInfinity = value =&gt; value === Infinity || value === -Infinity</span><br><span class="line"></span><br><span class="line">// 在数组中存在 Symbol/Undefined/Function/Infinity/NaN 类型会变成 null</span><br><span class="line">const processSpecialValueInArray = value =&gt;</span><br><span class="line">  isSymbol(value) || isFunction(value) || isUndefined(value) || isInfinity(value) || isNaN(value) ? null : value</span><br><span class="line"></span><br><span class="line">// 根据 JSON 规范处理属性值</span><br><span class="line">const processValue = value =&gt; &#123;</span><br><span class="line">  if (isInfinity(value) || isNaN(value)) &#123;</span><br><span class="line">    return null</span><br><span class="line">  &#125;</span><br><span class="line">  if (isString(value)) &#123;</span><br><span class="line">    return `&quot;$&#123;value&#125;&quot;`</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  return value</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">let s = Symbol(&apos;s&apos;)</span><br><span class="line">let obj = &#123;</span><br><span class="line">  str: &quot;123&quot;,</span><br><span class="line">  arr: [1, &#123; e: 1 &#125;, s, () =&gt; &#123;&#125;, undefined, Infinity, NaN],</span><br><span class="line">  obj: &#123; a: 1 &#125;,</span><br><span class="line">  Infinity: -Infinity,</span><br><span class="line">  nan: NaN,</span><br><span class="line">  undef: undefined,</span><br><span class="line">  symbol: s,</span><br><span class="line">  date: new Date(),</span><br><span class="line">  reg: /123/g,</span><br><span class="line">  func: () =&gt; &#123;&#125;,</span><br><span class="line">  dom: document.querySelector(&apos;body&apos;)</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">obj.loop = obj // 一个对象的属性值通过某种间接的方式指回该对象本身，即循环引用，属性也会被忽略！！！</span><br><span class="line"></span><br><span class="line">const jsonStringify = (function () &#123;</span><br><span class="line">  // 闭包 + WeakMap 防止循环引用</span><br><span class="line">  let wp = new WeakMap()</span><br><span class="line"></span><br><span class="line">  // 递归调用 jsonStringify 的都是闭包中的这个函数，而非 const 声明的 jsonStringify 函数</span><br><span class="line">  return function jsonStringify(obj) &#123;</span><br><span class="line">    if (wp.get(obj)) throw new TypeError(&apos;Converting circular structure to JSON&apos;)</span><br><span class="line">    let res = &quot;&quot;</span><br><span class="line"></span><br><span class="line">    if (isComplexDataType(obj)) &#123;</span><br><span class="line">      // 复杂类型的情况</span><br><span class="line">      if (obj.toJSON) return obj.toJSON; // 含有 toJSON 方法则直接调用</span><br><span class="line">      if (!isValidObj(obj)) return // 非法的复杂类型直接返回</span><br><span class="line">      </span><br><span class="line">      wp.set(obj, obj);</span><br><span class="line"></span><br><span class="line">      if (Array.isArray(obj)) &#123;</span><br><span class="line">        // 数组的情况</span><br><span class="line">        res += &quot;[&quot;;</span><br><span class="line">        let temp = []; //声明一个临时数组用来控制属性之间的逗号</span><br><span class="line">        obj.forEach((value) =&gt; &#123;</span><br><span class="line">          temp.push(isComplexDataType(value) &amp;&amp; !isFunction(value) ? jsonStringify(value) : `$&#123;processSpecialValueInArray(value, true)&#125;`)</span><br><span class="line">        &#125;);</span><br><span class="line">        res += `$&#123;temp.join(&apos;,&apos;)&#125;]`</span><br><span class="line">      &#125; else &#123;</span><br><span class="line">        // 对象的情况</span><br><span class="line">        res += &quot;&#123;&quot;;</span><br><span class="line">        let temp = [];</span><br><span class="line">        Object.keys(obj).forEach((key) =&gt; &#123;</span><br><span class="line">          // 值是对象的情况</span><br><span class="line">          if (isComplexDataType(obj[key])) &#123;</span><br><span class="line">            // 值是合法对象的情况</span><br><span class="line">            if (isValidObj(obj[key])) &#123;</span><br><span class="line">              temp.push(`&quot;$&#123;key&#125;&quot;:$&#123;jsonStringify(obj[key])&#125;`)</span><br><span class="line">            &#125; else if (isDate(obj[key])) &#123; // Date 类型调用 toISOString</span><br><span class="line">              temp.push(`&quot;$&#123;key&#125;&quot;:&quot;$&#123;obj[key].toISOString()&#125;&quot;`)</span><br><span class="line">            &#125; else if (!isFunction(obj[key])) &#123; // 其余非函数类型返回空对象</span><br><span class="line">              temp.push(`&quot;$&#123;key&#125;&quot;:&#123;&#125;`)</span><br><span class="line">            &#125;</span><br><span class="line">          &#125; else if (isValidBasicDataType(obj[key])) &#123;</span><br><span class="line">            // 值是基本类型</span><br><span class="line">            temp.push(`&quot;$&#123;key&#125;&quot;:$&#123;processValue(obj[key])&#125;`)</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        res += `$&#123;temp.join(&apos;,&apos;)&#125;&#125;`</span><br><span class="line">      &#125;</span><br><span class="line">    &#125; else if (isSymbol(obj)) &#123;</span><br><span class="line">      // Symbol 返回 undefined</span><br><span class="line">      return</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">      // 非 Symbol 的基本类型直接返回</span><br><span class="line">      return obj</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    return res</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)();</span><br><span class="line"></span><br><span class="line">console.log(jsonStringify(obj))</span><br><span class="line">console.log(JSON.stringify(obj))</span><br><span class="line"></span><br><span class="line">28.</span><br><span class="line">// JSON.parse 实现</span><br><span class="line">  1、eval 会执行JS代码，有XSS漏洞</span><br><span class="line">  2、new Function 与 eval 有相同的字符串参数特性</span><br><span class="line">  3、递归</span><br><span class="line">  4、状态机（比如正则引擎、词法分析，甚至是字符串匹配的 KMP 算法都能用它来解释。它代表着一种本质的逻辑：在 A 状态下，如果输入 B，就会转移到 C 状态）</span><br><span class="line">  5、script（模拟jsonP的方式拼接字符串然后以callBack的方式返回）</span><br><span class="line">  // https://github.com/youngwind/blog/issues/115</span><br><span class="line">  // var jsonStr = &apos;&#123; &quot;age&quot;: 20, &quot;name&quot;: &quot;jack&quot; &#125;&apos;</span><br><span class="line">  // var json = (new Function(jsonStr))();</span><br><span class="line">  // &#123;age: 20, name: &quot;jack&quot;&#125;</span><br><span class="line"></span><br><span class="line">29.</span><br><span class="line">// 手写一个符合 Promise/A+ 规范的 Promise</span><br><span class="line">// https://github.com/forthealllight/blog/issues/4</span><br><span class="line">// https://github.com/xieranmaya/blog/issues/2</span><br><span class="line">// 1、三种必须状态 pending | fulfilled(resolved) | rejected</span><br><span class="line">// 当处于 pending 状态的时候，可以转移到 fulfilled(resolved) 或者 rejected 状态</span><br><span class="line">// 当处于 fulfilled(resolved) 状态或者 rejected 状态的时候，就不可变</span><br><span class="line">// 2、一个promise必须有一个then方法，then方法接受两个参数：promise.then(onFulfilled, onRejected)</span><br><span class="line">// onFulfilled方法表示状态从pending——&gt;fulfilled(resolved)时所执行的方法，而onRejected表示状态从pending——&gt;rejected所执行的方法</span><br><span class="line">// 3、为了实现链式调用，then方法必须返回一个promise：promise = promise.then(onFulfilled, onRejected)</span><br><span class="line">function Promise (excutor) &#123;</span><br><span class="line">  let that = this; // 缓存当前 promise 实例对象</span><br><span class="line">  that.status = &apos;pending&apos;; // 初始状态</span><br><span class="line">  that.value = undefined; // fulfilled 状态时 返回的信息 if pending -&gt; fulfilled</span><br><span class="line">  that.reason = undefined; // rejected 状态时 拒绝的原因 if pending -&gt; rejected</span><br><span class="line">  that.onFulfilledCallbacks = []; // 存储 fulfilled 状态对应的 onFulfilled 函数, to deal with async(resolved)</span><br><span class="line">  that.onRejectedCallbacks = []; // 存储 rejected 状态对应的 onRejected 函数, to deal with async(rejeced)</span><br><span class="line"></span><br><span class="line">  // value 成功态时接收的终值</span><br><span class="line">  // pending -&gt; fulfilled</span><br><span class="line">  function resolve (value) &#123;</span><br><span class="line">    if(value instanceof Promise) &#123;</span><br><span class="line">      return value.then(resolve, reject);</span><br><span class="line">    &#125;</span><br><span class="line">    // 实践中要确保 onFulfilled 和 onRejected 方法异步执行，且应该在 then 方法被调用的那一轮事件循环之后的新执行栈中执行。</span><br><span class="line">    setTimeout(() =&gt; &#123;</span><br><span class="line">      // 调用 resolve 回调对应 onFulfilled 函数</span><br><span class="line">      if (that.status === &apos;pending&apos;) &#123;</span><br><span class="line">        // 只能由 pending 状态 =&gt; fulfilled 状态 (避免调用多次 resolve reject)</span><br><span class="line">        that.status = &apos;fulfilled&apos;;</span><br><span class="line">        that.value = value;</span><br><span class="line">        that.onFulfilledCallbacks.forEach(cb =&gt; cb(that.value)); // 遍历回调数组并执行</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;); // delay 默认值为0，DOM_MIN_TIMEOUT_VALUE是4ms</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  // reason失败态时接收的拒因</span><br><span class="line">  // pending -&gt; rejected</span><br><span class="line">  function reject (reason) &#123;</span><br><span class="line">    setTimeout(() =&gt; &#123;</span><br><span class="line">      // 调用 reject 回调对应 onRejected 函数</span><br><span class="line">      if (that.status === &apos;pending&apos;) &#123;</span><br><span class="line">        // 只能由 pending 状态 =&gt; rejected状态 (避免调用多次resolve reject)</span><br><span class="line">        that.status = &apos;rejected&apos;;</span><br><span class="line">        that.reason = reason;</span><br><span class="line">        that.onRejectedCallbacks.forEach(cb =&gt; cb(that.reason));</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  try &#123;</span><br><span class="line">    excutor(resolve, reject); // According to the definition that the function &quot;constructor&quot; accept two parameters</span><br><span class="line">  &#125; catch (e) &#123;</span><br><span class="line">    reject(e); // error catch 执行函数过程中会遇到错误，需要捕获错误并且执行 reject 函数</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Promise.prototype.then = function (onFulfilled, onRejected) &#123;</span><br><span class="line">  const that = this;</span><br><span class="line">  // 每个 then 函数都需要返回一个新的 Promise 对象</span><br><span class="line">  let newPromise;</span><br><span class="line">  // 处理参数默认值 保证参数后续能够继续执行</span><br><span class="line">  onFulfilled = typeof onFulfilled === &quot;function&quot; ? onFulfilled : value =&gt; value;</span><br><span class="line">  onRejected = typeof onRejected === &quot;function&quot; ? onRejected : reason =&gt; &#123; throw reason &#125;;</span><br><span class="line"></span><br><span class="line">  if (that.status === &apos;pending&apos;) &#123;</span><br><span class="line">    // 等待态</span><br><span class="line">    // 当异步调用 resolve/reject 时 将 onFulfilled/onRejected 收集暂存到集合中</span><br><span class="line">    newPromise = new Promise((resolve, reject) =&gt; &#123;</span><br><span class="line">      that.onFulfilledCallbacks.push(() =&gt; &#123;</span><br><span class="line">        try &#123;</span><br><span class="line">          let x = onFulfilled(that.value); // 规范规定</span><br><span class="line">          resolvePromise(newPromise, x, resolve, reject);</span><br><span class="line">        &#125; catch(e) &#123;</span><br><span class="line">          reject(e);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;);</span><br><span class="line"></span><br><span class="line">      that.onRejectedCallbacks.push(() =&gt; &#123;</span><br><span class="line">        try &#123;</span><br><span class="line">          let x = onRejected(that.reason);</span><br><span class="line">          resolvePromise(newPromise, x, resolve, reject);</span><br><span class="line">        &#125; catch(e) &#123;</span><br><span class="line">          reject(e);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;);</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  if (that.status === &apos;fulfilled&apos;) &#123;</span><br><span class="line">    // 成功态（resolved）</span><br><span class="line">    newPromise = new Promise((resolve, reject) =&gt; &#123;</span><br><span class="line">      // 规范规定：传入的函数的函数体需要异步执行</span><br><span class="line">      // Promise/A+ 规范有说Promise.then的回调执行必须是异步的，实现方式是多种多样的，可以选择Macro Task机制，也可以选择Micro Task机制，这边用的setTimeout就是Macro Task机制</span><br><span class="line">      setTimeout(() =&gt; &#123;</span><br><span class="line">        try&#123;</span><br><span class="line">          let x = onFulfilled(that.value);</span><br><span class="line">          resolvePromise(newPromise, x, resolve, reject); // 新的 promise resolve 上一个 onFulfilled 的返回值</span><br><span class="line">        &#125; catch(e) &#123;</span><br><span class="line">          reject(e); // 捕获前面 onFulfilled 中抛出的异常 then(onFulfilled, onRejected);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;);</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  if (that.status === &apos;rejected&apos;) &#123;</span><br><span class="line">    // 失败态</span><br><span class="line">    newPromise = new Promise((resolve, reject) =&gt; &#123;</span><br><span class="line">      setTimeout(() =&gt; &#123;</span><br><span class="line">        try &#123;</span><br><span class="line">          let x = onRejected(that.reason);</span><br><span class="line">          resolvePromise(newPromise, x, resolve, reject);</span><br><span class="line">        &#125; catch(e) &#123;</span><br><span class="line">          reject(e);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;);</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  return newPromise</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">// 实现兼容多种 Promise</span><br><span class="line">// Tips:</span><br><span class="line">// resolvePromise 函数，该函数接受当前的 promise、onFullfilled 函数或者 onRejected 函数的返回值 x、resolve 和 reject 作为参数</span><br><span class="line">// 处理 then 函数中的 onFullfilled 和 onRejected 方法的返回值问题</span><br><span class="line">// then函数的返回值 ——&gt; 返回一个新promise，从而实现链式调用</span><br><span class="line">// then函数中的 onFullfilled 和 onRejected 方法 ——&gt; 返回基本值或者新的promise</span><br><span class="line">function resolvePromise (promise, x, resolve, reject) &#123;</span><br><span class="line">  // promise must !== x</span><br><span class="line">  if (promise === x) &#123;</span><br><span class="line">    // 造成循环引用</span><br><span class="line">    return reject(new TypeError(&quot;TypeError: Cyclic reference&quot;));</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  let isCalled = false; // 是否已经调用过函数</span><br><span class="line"></span><br><span class="line">  if (x !== null &amp;&amp; (typeof x === &quot;object&quot; || typeof x === &quot;function&quot;)) &#123;</span><br><span class="line">    try &#123;</span><br><span class="line">      let then = x.then;</span><br><span class="line"></span><br><span class="line">      if (typeof then === &quot;function&quot;) &#123;</span><br><span class="line">        // 如果 then 是函数类型的话，就将 x 作为函数的作用域 this 调用之，并且传递两个回调函数作为参数，第一个参数叫做 resolvePromise ，第二个参数叫做 rejectPromise，两个回调函数都需要判断是否已经执行过函数，然后进行相应的逻辑</span><br><span class="line">        then.call(</span><br><span class="line">        x,</span><br><span class="line">        y =&gt; &#123;</span><br><span class="line">          if (isCalled) return;</span><br><span class="line">          isCalled = true;</span><br><span class="line">          resolvePromise(promise, y, resolve, reject)</span><br><span class="line">        &#125;,</span><br><span class="line">        e =&gt; &#123;</span><br><span class="line">          if (isCalled) return;</span><br><span class="line">          isCalled = true;</span><br><span class="line">          reject(e);</span><br><span class="line">        &#125;)</span><br><span class="line">      &#125; else &#123;</span><br><span class="line">        resolve(x); // 仅仅是一个函数或者是对象</span><br><span class="line">      &#125;</span><br><span class="line">    &#125; catch (e) &#123;</span><br><span class="line">      if (isCalled) return;</span><br><span class="line">      isCalled = true;</span><br><span class="line">      reject(e);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; else &#123;</span><br><span class="line">    resolve(x); // 返回的基本类型，直接resolve</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">export default Promise</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">前端2018</span><br><span class="line">// 1. 基础扎实，对主流技术栈十分了解</span><br><span class="line">// 2. 技术发展兼顾前后端</span><br><span class="line">// 3. 职业素养更加综合</span><br><span class="line">// 4. 资历背景优秀</span><br><span class="line">// 对原理的理解</span><br><span class="line">// 优秀前端的核心竞争力其实就是「折腾」</span><br><span class="line">// ES6的所有新特性</span><br><span class="line">// webpack Parcel</span><br><span class="line">// PWA</span><br><span class="line">// webapck4</span><br><span class="line">// 前端工程化</span><br><span class="line"></span><br><span class="line">前端2019</span><br><span class="line">// React / Vue</span><br><span class="line">// WebAssembly</span><br><span class="line">// TypeScript</span><br><span class="line">// React hooks</span><br><span class="line">// CSS-in-JS</span><br><span class="line">// Vue 3.x</span><br><span class="line">// Flutter</span><br><span class="line">// Next / Nuxt</span><br><span class="line">// GraphQL</span><br><span class="line">// Deno</span><br><span class="line">// Docker，Kubernetes</span><br></pre></td></tr></table></figure>
<h4 id="JS"><a href="#JS" class="headerlink" title="JS"></a>JS</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line">// Primitive/Object</span><br><span class="line">* typeof 对于原始类型来说，除了 null 都可以显示正确的类型</span><br><span class="line">* typeof 对于对象来说，除了函数都会显示 object</span><br><span class="line">* instanceof 内部机制是通过原型链来判断的</span><br><span class="line">* foo instanceof Foo在语言内部，实际调用的是Foo[Symbol.hasInstance](foo)</span><br><span class="line">* Symbol.toPrimitive 该方法在转原始类型时调用优先级最高</span><br><span class="line">* 比较运算符: 如果是对象，就通过 toPrimitive 转换对象; 如果是字符串，就通过 unicode 字符索引来比较</span><br><span class="line">* 箭头函数其实是没有 this 的，箭头函数中的 this 只取决包裹箭头函数的第一个普通函数的 this</span><br><span class="line">* bind 这些改变上下文的 API 了，对于这些函数来说，this 取决于第一个参数，如果第一个参数为空，那么就是 window</span><br><span class="line">* 不管我们给函数 bind 几次，fn 中的 this 永远由第一次 bind 决定</span><br><span class="line">* this 的规则:new 的方式优先级最高，接下来是 bind 这些函数，然后是 obj.foo() 这种调用方式，最后是 foo 这种调用方式，同时，箭头函数的 this 一旦被绑定，就不会再被任何方式所改变</span><br><span class="line">* Function 的 toString，返回的是定义函数时，等号右边的全部内容字符串</span><br><span class="line">* 非基础数据类型的对象，在遇到 “+” 操作时，都是先调用自己的 toString 方法，自己没有就找原型上的，得到结果之后再拼接。只是每种对象默认的 toString 方法实现不一样而已</span><br><span class="line">* 如果a,b计算值中有对象,那么把对象调用 [Symbol.toPrimitive]转换成基础类型,具体在转换过程中是先调用 valueOf还是 ToString,是要看传给 [Symbol.toPrimitive]的参数,对于 + 号操作符,是优先调用 valueOf,然后 ToString</span><br><span class="line">* 1.&apos;如果另一个操作符为Array、number等，则将操作符通过toString()转为字符串进行拼接&apos;  转换成字符串的优先级是  [Symbol.toString]&gt; valueOf &gt; toString,并不仅仅是 toString</span><br><span class="line">  2.整个流程应该是</span><br><span class="line">    1)如果左右两个操作数有一个是对象,那么先将对象按照 [Symbol.toString]&gt; valueOf &gt; toString来转换成基本数据类型</span><br><span class="line">    2)转换后的两个操作数类型中如果Sstring,那么把另外不是String的操作数转换成字符串按照字符串拼接</span><br><span class="line">    3)转换后的两个操作数类型中没有String,那么把左右操作数都转换数字进行计算</span><br><span class="line">* 值类型 == 值类型 // 相当于 Number(值类型) == Number(值类型)</span><br><span class="line">  引用类型 == 值类型 // 对象转化成原始类型的值，再进行比较。比较规则：数组与数值进行比较，会先转成数值，再进行比较；与字符串进行比较，会先转成字符串，再进行比较；与布尔值进行比较，两个运算子都会先转成数值，然后再进行比较。</span><br><span class="line">    [] == [] // false []属于引用类型，在两个[]分别指向不同的堆内存</span><br><span class="line">    [] == ![] // true ![]为false -&gt; [] == false -&gt; ToPrimitive([]) == false -&gt; &apos;&apos; == false -&gt; 0 == 0 -&gt; true</span><br><span class="line">    &apos; \t\r\n &apos; == 0 // true 转义字符 Number(&apos; \t\r\n &apos;) -&gt; 0</span><br><span class="line">* 浅拷贝</span><br><span class="line">    直接赋值</span><br><span class="line">    Object.assign (当object只有一层的时候，是深拷贝)</span><br><span class="line">    Array.prototype.concat()</span><br><span class="line">    Array.prototype.slice()</span><br><span class="line">    展开运算符 ...</span><br><span class="line">  深拷贝</span><br><span class="line">    // 1、JSON安全</span><br><span class="line">    var newObj = JSON.parse(JSON.stringify(someObj));</span><br><span class="line">    问题：</span><br><span class="line">      1.无法实现对函数 、RegExp等特殊对象的克隆</span><br><span class="line">      2.会抛弃对象的constructor,所有的构造函数会指向Object</span><br><span class="line">      3.对象有循环引用,会报错</span><br><span class="line">      4.忽略undefined和symbol</span><br><span class="line"></span><br><span class="line">    // 2、复杂数据类型：递归&amp;遍历(考虑好多种边界情况，比如原型链如何处理、DOM 如何处理等)</span><br><span class="line">    // https://lodash.com/docs#cloneDeep</span><br><span class="line">    deepClone() &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">* 原型</span><br><span class="line">    // https://note.youdao.com/ynoteshare1/index.html?id=a4b93ec64df3c32ef7a7c9fa2da64c20&amp;type=note</span><br><span class="line">    // https://image-static.segmentfault.com/167/246/1672461057-58204120a29cc_articlex</span><br><span class="line">    Object 是所有对象的爸爸，所有对象都可以通过 __proto__ 找到它</span><br><span class="line">    Function 是所有函数的爸爸，所有函数都可以通过 __proto__ 找到它</span><br><span class="line">    函数的 prototype 是一个对象</span><br><span class="line">    对象的 __proto__ 属性指向原型， __proto__ 将对象和原型连接起来组成了原型链</span><br></pre></td></tr></table></figure>
<h4 id="ES6"><a href="#ES6" class="headerlink" title="ES6"></a>ES6</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br></pre></td><td class="code"><pre><span class="line">* hoisting: 提升的是声明</span><br><span class="line">* 函数提升优先于变量提升，函数提升会把整个函数挪到作用域顶部，变量提升只会把声明挪到作用域顶部</span><br><span class="line">* let 和 const 声明变量，变量并不会被挂载到 window 上</span><br><span class="line">* 寄生组合继承:</span><br><span class="line">    function Parent(value) &#123;</span><br><span class="line">      this.value = value</span><br><span class="line">    &#125;</span><br><span class="line">    Parent.prototype.getValue = function() &#123;</span><br><span class="line">      console.log(this.value)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function Child(value) &#123;</span><br><span class="line">      Parent.call(this, value)</span><br><span class="line">    &#125;</span><br><span class="line">    Child.prototype = Object.create(Parent.prototype, &#123;</span><br><span class="line">      constructor: &#123;</span><br><span class="line">        value: Child,</span><br><span class="line">        enumerable: false,</span><br><span class="line">        configurable: true,</span><br><span class="line">        writable: true</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;)</span><br><span class="line"></span><br><span class="line">    const child = new Child(123)</span><br><span class="line"></span><br><span class="line">    child.getValue() // 123</span><br><span class="line">    child instanceof Parent // true</span><br><span class="line">* 类继承</span><br><span class="line">    // class 实现继承的核心在于使用 extends 表明继承自哪个父类，并且在子类构造函数中必须调用 super，因为这段代码可以看成 Parent.call(this, value)</span><br><span class="line">    class Person &#123;</span><br><span class="line">      constructor(f, l) &#123;</span><br><span class="line">        this.f = f;</span><br><span class="line">        this.l = l;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      personMethod() &#123;</span><br><span class="line">        console.log(this.f)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    class Employee extends Person &#123;</span><br><span class="line">      constructor(f, l, position) &#123;</span><br><span class="line">        super(f, l);</span><br><span class="line">        this.position = position;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      employeeMethod() &#123;</span><br><span class="line">        // ...</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    let employee = new Employee(123)</span><br><span class="line">    employee.personMethod() // 123</span><br><span class="line">* 模块化</span><br><span class="line">    1、立即执行函数</span><br><span class="line">    2、AMD 和 CMD</span><br><span class="line">      // AMD</span><br><span class="line">      define([&apos;./a&apos;, &apos;./b&apos;], function(a, b) &#123;</span><br><span class="line">        // 加载模块完毕可以使用</span><br><span class="line">        a.do()</span><br><span class="line">        b.do()</span><br><span class="line">      &#125;)</span><br><span class="line">      // CMD</span><br><span class="line">      define(function(require, exports, module) &#123;</span><br><span class="line">        // 加载模块</span><br><span class="line">        // 可以把 require 写在函数体的任意地方实现延迟加载</span><br><span class="line">        var a = require(&apos;./a&apos;)</span><br><span class="line">        a.doSomething()</span><br><span class="line">      &#125;)</span><br><span class="line">    3、CommonJS（就是包装了一层立即执行函数）</span><br><span class="line">    4、ES module</span><br><span class="line">      // ES Module 是原生实现的模块化方案，与 CommonJS 有以下几个区别</span><br><span class="line">      CommonJS 支持动态导入，也就是 require($&#123;path&#125;/xx.js)，后者目前不支持，但是已有提案</span><br><span class="line">      CommonJS 是同步导入，因为用于服务端，文件都在本地，同步导入即使卡住主线程影响也不大。而后者是异步导入，因为用于浏览器，需要下载文件，如果也采用同步导入会对渲染有很大影响</span><br><span class="line">      CommonJS 在导出时都是值拷贝，就算导出的值变了，导入的值也不会改变，所以如果想更新值，必须重新导入一次。但是 ES Module 采用实时绑定的方式，导入导出的值都指向同一个内存地址，所以导入值会跟随导出值变化</span><br><span class="line">      ES Module 会编译成 require/exports 来执行的</span><br><span class="line">        // 引入模块 API</span><br><span class="line">        import XXX from &apos;./a.js&apos;</span><br><span class="line">        import &#123; XXX &#125; from &apos;./a.js&apos;</span><br><span class="line">        // 导出模块 API</span><br><span class="line">        export function a() &#123;&#125;</span><br><span class="line">        export default function() &#123;&#125;</span><br><span class="line">    5、Proxy</span><br><span class="line">      // let p = new Proxy(target, handler) target 代表需要添加代理的对象，handler 用来自定义对象中的操作，比如可以用来自定义 set 或者 get 函数</span><br><span class="line">* map</span><br><span class="line">    // 作用是生成一个新数组，遍历原数组，将每个元素拿出来做一些变换然后放入到新的数组中</span><br><span class="line">    // map 的回调函数接受三个参数，分别是当前索引元素，索引，原数组</span><br><span class="line">* filter</span><br><span class="line">    // 生成一个新数组，在遍历数组的时候将返回值为 true 的元素放入新数组，我们可以利用这个函数删除一些不需要的元素</span><br><span class="line">* reduce</span><br><span class="line">    // arr.reduce(callback(accumulator, currentValue, currentIndex, array), initialValue)</span><br><span class="line">    // 回调函数第一次执行时，accumulator 和currentValue的取值有两种情况：如果调用reduce()时提供了initialValue，accumulator取值为initialValue，currentValue取数组中的第一个值；如果没有提供 initialValue，那么accumulator取数组中的第一个值，currentValue取数组中的第二个值</span><br><span class="line">    // 可以将数组中的元素通过回调函数最终转换为一个值</span><br><span class="line">    // 接受两个参数，分别是回调函数和初始值</span><br><span class="line">      const arr = [1, 2, 3]</span><br><span class="line">      const sum = arr.reduce((acc, current) =&gt; acc + current, 0)</span><br><span class="line">      console.log(sum)</span><br><span class="line">      // 首先初始值为 0，该值会在执行第一次回调函数时作为第一个参数传入</span><br><span class="line">      // 回调函数接受四个参数，分别为累计值、当前元素、当前索引、原数组，后三者想必大家都可以明白作用，这里着重分析第一个参数</span><br><span class="line">      // 在一次执行回调函数时，当前值和初始值相加得出结果 1，该结果会在第二次执行回调函数时当做第一个参数传入</span><br><span class="line">      // 所以在第二次执行回调函数时，相加的值就分别是 1 和 2，以此类推，循环结束后得到结果 6</span><br></pre></td></tr></table></figure>
<ul>
<li>并发（concurrency）和并行（parallelism）<br>  // 并发是宏观概念，我分别有任务 A 和任务 B，在一段时间内通过任务间的切换完成了这两个任务，这种情况就可以称之为并发。<br>  // 并行是微观概念，假设 CPU 中存在两个核心，那么我就可以同时完成任务 A、B。同时完成多个任务的情况就可以称之为并行。</li>
<li>Callback (Callback hell)<br>  // 嵌套函数存在耦合性，一旦有所改动，就会牵一发而动全身<br>  // 嵌套函数一多，就很难处理错误<br>  1.Generator<pre><code>// 控制函数的执行
// 返回一个迭代器
// 可以通过 Generator 函数解决回调地狱的问题
</code></pre>  2.Promise<pre><code>// 很好地解决了回调地狱的问题
// 构造 Promise 的时候，构造函数内部的代码是立即执行的
// Promise 实现了链式调用，也就是说每次调用 then 之后返回的都是一个 Promise，并且是一个全新的 Promise，原因也是因为状态不可变。如果你在 then 中 使用了 return，那么 return 的值会被 Promise.resolve() 包装
// 无法取消 Promise，错误需要通过回调函数捕获
</code></pre>  3.async 及 await<pre><code>// 一个函数如果加上 async ，那么该函数就会返回一个 Promise
// async 就是将函数返回值使用 Promise.resolve() 包裹了下，和 then 中处理返回值一样，并且 await 只能配套 async 使用
// await 就是 generator 加上 Promise 的语法糖，且内部实现了自动执行 generator，会让出线程，阻塞后面的代码先执行async外的同步代码
// 如果一个 Promise 被传递给一个 await 操作符，await 将等待 Promise 正常处理完成并返回其处理结果
// 优雅地解决回调地狱问题
// 缺点：await 将异步代码改造成了同步代码，如果多个异步代码没有依赖性却使用了 await 会导致性能上的降低
</code></pre></li>
<li>setTimeout、setInterval、requestAnimationFrame<br>  // JS 是单线程执行的，如果前面的代码影响了性能，就会导致 setTimeout 不会按期执行<br>  // requestAnimationFrame 自带函数节流功能，基本可以保证在 16.6 毫秒内只执行一次（不掉帧的情况下），并且该函数的延时效果是精确的，没有其他定时器时间不准的问题<br>  // 定时器指定的时间间隔，表示的是何时将定时器的代码添加到消息队列，而不是何时执行代码</li>
<li><p>Event Loop<br>  // <a href="https://jakearchibald.com/2015/tasks-microtasks-queues-and-schedules/" target="_blank" rel="noopener">https://jakearchibald.com/2015/tasks-microtasks-queues-and-schedules/</a><br>  // 进程与线程：进程描述了 CPU 在运行指令及加载和保存上下文所需的时间，放在应用上来说就代表了一个程序。线程是进程中的更小单位，描述了执行一段指令所需的时间<br>  // 执行栈：存储函数调用的栈结构，遵循先进后出的原则，执行 JS 代码的时候其实就是往执行栈中放入函数，遇到异步的代码时，会被挂起并在需要执行的时候加入到 Task（有多种 Task） 队列中。一旦执行栈为空，Event Loop 就会从 Task 队列中拿出需要执行的代码并放入执行栈中执行，所以本质上来说 JS 中的异步还是同步行为<br>  // 在程序的整个生命周期中不停的重复 主任务 ——&gt; micro task ——&gt; 渲染视图 ——&gt; macro task 的操作<br>  // 微任务会在当前宏任务的同步代码执行完毕，才会依次执行<br>  1.浏览器中</p>
<pre><code>// 首先执行同步代码，这属于宏任务
// 当执行完所有同步代码后，执行栈为空，查询是否有异步代码需要执行
// 执行所有微任务
// 当执行完所有微任务后，如有必要会渲染页面
// 然后开始下一轮 Event Loop，执行宏任务中的异步代码，也就是 setTimeout 中的回调函数

// 不同的任务源会被分配到不同的 Task 队列中，任务源可以分为 微任务（microtask） 和 宏任务（macrotask）。在 ES6 规范中，microtask 称为 jobs，macrotask 称为 task
// 宏任务包括：Events，Parsing，Callbacks，Using a resource，Reacting to DOM manipulation，script，setTimeout，setInterval，setImmediate，I/O，UI rendering
// 微任务包括：process.nextTick，promise，MutationObserver，其中 process.nextTick 为 Node 独有
</code></pre><p>  2.Node中</p>
<pre><code>// 分为 6 个阶段，它们会按照顺序反复运行。每当进入某一个阶段的时候，都会从对应的回调队列中取出函数去执行。当队列为空或者执行的回调函数数量到达系统设定的阈值，就会进入下一阶段
2.1 macrotask
  timer // 执行 setTimeout 和 setInterval 回调，并且是由 poll 阶段控制的
  I/O // 处理一些上一轮循环中的少数未执行的 I/O 回调
  idle，prepare
  poll // 回到 timer 阶段执行回调；执行 I/O 回调
  check // 执行 setImmediate
  close callbacks // 执行 close 事件
2.2 microtask
  Timers
  IO Callbacks
  IO Polling
  Set Immediate
  Close Events
</code></pre></li>
<li>process.nextTick<br>  // 它有一个自己的队列，当每个阶段完成后，如果存在 nextTick 队列，就会清空队列中的所有回调函数，并且优先于其他 microtask 执行</li>
<li>事件触发有三个阶段<br>  1.window 往事件触发处传播，遇到注册的捕获事件会触发<br>  2.传播到事件触发处时触发注册的事件<br>  3.从事件触发处往 window 传播，遇到注册的冒泡事件会触发<br>  // 使用 addEventListener 注册事件，该函数的第三个参数可以是布尔值，也可以是对象。对于布尔值 useCapture 参数来说，该参数默认值为 false ，useCapture 决定了注册的事件是捕获事件还是冒泡事件。对于对象参数来说，可以使用以下几个属性：<pre><code>1.capture：布尔值，和 useCapture 作用一样
2.once：布尔值，值为 true 表示该回调只会调用一次，调用后会移除监听
3.passive：布尔值，表示永远不会调用 preventDefault
</code></pre>  // stopPropagation 是用来阻止事件冒泡的，其实该函数也可以阻止捕获事件<br>  // stopImmediatePropagation 同样也能实现阻止事件，但是还能阻止该事件目标执行别的注册事件<br>  // 事件代理的方式相较于直接给目标注册事件：节省内存、不需要给子节点注销事件</li>
<li><p>跨域同源策略：主要是用来防止 CSRF 攻击（利用用户的登录态发起恶意请求）<br>  // 请求发出去了，被浏览器拦截了响应<br>  1.JSONP</p>
<pre><code>function jsonp(url, jsonpCallback, success) {
  let script = document.createElement(&apos;script&apos;)
  script.src = url
  script.async = true
  script.type = &apos;text/javascript&apos;
  window[jsonpCallback] = function(data) {
    success &amp;&amp; success(data)
  }
  document.body.appendChild(script)
}

jsonp(&apos;http://xxx&apos;, &apos;callback&apos;, function(value) {
  console.log(value)
})
</code></pre><p>  2.CORS</p>
<pre><code>// 服务端设置 Access-Control-Allow-Origin 就可以开启 CORS
// 简单请求
// 复杂请求：预检请求 OPTIONS
</code></pre><p>  3.document.domain</p>
<pre><code>// 用于二级域名相同的情况
</code></pre><p>  4.postMessage</p>
<pre><code>// 用于获取嵌入页面中的第三方页面数据。一个页面发送消息，另一个页面判断来源并接收消息
// 发送消息端
window.parent.postMessage(&apos;message&apos;, &apos;http://test.com&apos;)
// 接收消息端
var mc = new MessageChannel()
mc.addEventListener(&apos;message&apos;, event =&gt; {
  var origin = event.origin || event.originalEvent.origin
  if (origin === &apos;http://test.com&apos;) {
    console.log(&apos;验证通过&apos;)
  }
})
</code></pre><p>  5.nginx反向代理</p>
</li>
<li>cookie<br>// http-only 不能通过 JS 访问 Cookie，减少 XSS 攻击<br>// secure 只能在协议为 HTTPS 的请求中携带<br>// same-site 规定浏览器不能在跨域请求中携带 Cookie，减少 CSRF 攻击</li>
<li>Service Worker<br>// 请求拦截和结果缓存<br>// 独立线程，网络代理，一般可以用来实现缓存功能<br>// 传输协议必须为 HTTPS，涉及到请求拦截，所以必须使用 HTTPS 协议来保障安全<br>1.注册 Service Worker<br>2.监听到 install 事件以后就可以缓存需要的文件，那么在下次用户访问的时候就可以通过拦截请求的方式查询是否存在缓存，存在缓存的话就可以直接读取缓存文件，否则就去请求数据</li>
<li>Web Worker<br>// 开辟线程执行耗时js</li>
<li>浏览器缓存机制<br>  缓存位置<pre><code>1.Service Worker
2.Memory Cache
  // 对于大文件来说，大概率是不存储在内存中的，反之优先
  // 当前系统内存使用率高的话，文件优先存储进硬盘
3.Disk Cache
  // 容量和存储时效性
  // 即使在跨站点的情况下，相同地址的资源一旦被硬盘缓存下来，就不会再次去请求数据
4.Push Cache
  // HTTP/2
  // 缓存时间也很短暂，只在会话（Session）中存在，一旦会话结束就被释放
  // 可以推送 no-cache 和 no-store 的资源
  // 一旦连接被关闭，Push Cache 就被释放
  // 多个页面可以使用相同的 HTTP/2 连接，也就是说能使用同样的缓存
  // Push Cache 中的缓存只能被使用一次
  // 浏览器可以拒绝接受已经存在的资源推送
  // 你可以给其他域名推送资源
5.网络请求
</code></pre>  缓存策略<pre><code>// 强缓存和协商缓存
// 缓存策略都是通过设置 HTTP Header 来实现
1.强缓存
  // Expires 和 Cache-Control
  // 表示在缓存期间不需要请求，state code 为 200
  // Expires 受限于本地时间，如果修改了本地时间，可能会造成缓存失效
  // Cache-Control 优先级高于 Expires, max-age=30 该属性值表示资源会在 30 秒后过期，需要再次请求
2.协商缓存
  // Last-Modified 和 ETag
  Last-Modified 和 If-Modified-Since
    // Last-Modified 表示本地文件最后修改日期
    // If-Modified-Since 会将 Last-Modified 的值发送给服务器，询问服务器在该日期后资源是否有更新，有更新的话就会将新的资源发送回来，否则返回 304 状态码
    弊端:
    // 如果本地打开缓存文件，即使没有对文件进行修改，但还是会造成 Last-Modified 被修改，服务端不能命中缓存导致发送相同的资源
    // 因为 Last-Modified 只能以秒计时，如果在不可感知的时间内修改完成文件，那么服务端会认为资源还是命中了，不会返回正确的资源
  ETag 和 If-None-Match
    // ETag 优先级比 Last-Modified 高
// 未设置缓存策略：启发式的算法，通常会取响应头中的 Date 减去 Last-Modified 值的 10% 作为缓存时间
</code></pre></li>
<li><p>浏览器渲染原理<br>  1.解析 HTML：Byte Data -&gt; String -&gt; Token -&gt; Node -&gt; DOM Tree<br>  2.解析 CSS：Byte Data -&gt; String -&gt; Token -&gt; Node -&gt; CSSOM<br>  3.Render Tree：DOM Tree ＋ CSSOM<br>  4.当浏览器生成渲染树以后，就会根据渲染树来进行布局（也可以叫做回流），然后调用 GPU 绘制，合成图层，显示在屏幕上</p>
<p>  Tip：插入几万个 DOM，如何实现页面不卡顿？<br>  // requestAnimationFrame<br>  // 虚拟滚动（virtualized scroller）：只渲染可视区域内的内容，非可见区域的那就完全不渲染了，当用户在滚动的时候就实时去替换渲染的内容</p>
<p>  // defer：立即下载，但延迟执行<br>  // async：JS 文件下载和解析不会阻塞渲染</p>
<p>  // 关键渲染路径</p>
</li>
<li>安全<br>  1.XSS 分持久型和非持久型<pre><code>// 转义字符
// 白名单
// CSP
  // 设置 HTTP Header 中的 Content-Security-Policy
  // 设置 meta 标签的方式 &lt;meta http-equiv=&quot;Content-Security-Policy&quot;&gt;
</code></pre>  2.CSRF<pre><code>// SameSite
// 验证 Referer
// Token
</code></pre>  3.点击劫持<pre><code>// X-FRAME-OPTIONS 一个 HTTP 响应头，防御用 iframe 嵌套的点击劫持攻击
  // DENY，表示页面不允许通过 iframe 的方式展示
  // SAMEORIGIN，表示页面可以在相同域名下通过 iframe 的方式展示
  // ALLOW-FROM，表示页面可以在指定来源的 iframe 中展示
</code></pre>  4.中间人攻击<pre><code>// 中间人攻击是攻击方同时与服务端和客户端建立起了连接，并让对方认为连接是安全的，但是实际上整个通信过程都被攻击者控制了
</code></pre></li>
<li>性能优化<br>  // 图片优化<br>  // <link rel="dns-prefetch" href><br>  // <link rel="preload" href><br>  // <link rel="prerender" href><br>  // 懒执行<br>  // 懒加载<br>  // CDN</li>
<li>Webpack 性能优化<ol>
<li>减少 Webpack 打包时间<br>1.1 优化 Loader<br> // 优化 Loader 的文件搜索范围：include、exclude<br> // 将 Babel 编译过的文件缓存起来：loader: ‘babel-loader?cacheDirectory=true’<br>1.2 HappyPack<br> // HappyPack 可以将 Loader 的同步执行转换为并行的<br> module: {<br>   loaders: [<pre><code>{
  test: /\.js$/,
  include: [resolve(&apos;src&apos;)],
  exclude: /node_modules/,
  // id 后面的内容对应下面
  loader: &apos;happypack/loader?id=happybabel&apos;
}
</code></pre>   ]<br> },<br> plugins: [<br>   new HappyPack({<pre><code>id: &apos;happybabel&apos;,
loaders: [&apos;babel-loader?cacheDirectory&apos;],
// 开启 4 个线程
threads: 4
</code></pre>   })<br> ]<br>1.3 DllPlugin<br> // DllPlugin 可以将特定的类库提前打包然后引入<br> // webpack.DllPlugin()<br> // webpack.DllReferencePlugin()<br>1.4 代码压缩<br> // Webpack3: webpack-parallel-uglify-plugin 来并行运行 UglifyJS<br> // Webpack4: mode设置production</li>
<li>减少 Webpack 打包后的文件体积<br>2.1 按需加载<br> // 每个路由页面单独打包为一个文件<br>2.2 Scope Hoisting<br> // 分析出模块之间的依赖关系，尽可能的把打包出来的模块合并到一个函数中去<br> // Webpack4: optimization.concatenateModules = true<br>2.3 Tree Shaking<br> // 实现删除项目中未被引用的代码<br>2.4 开启gzip压缩</li>
</ol>
</li>
<li>自己实现一个Webpack打包工具？<br>  // <a href="https://www.youtube.com/watch?v=Gc9-7PBqOC8&amp;list=LLHK1mTHpwrUeYgF5gu-Kd4g" target="_blank" rel="noopener">https://www.youtube.com/watch?v=Gc9-7PBqOC8&amp;list=LLHK1mTHpwrUeYgF5gu-Kd4g</a><br>  // <a href="https://github.com/ronami/minipack/blob/master/src/minipack.js" target="_blank" rel="noopener">https://github.com/ronami/minipack/blob/master/src/minipack.js</a></li>
<li>MVC or MVVM<br>  // MVC 有一个巨大的缺陷就是控制器承担的责任太大了，随着项目愈加复杂，控制器中的代码会越来越臃肿，导致出现不利于维护的情况<br>  // 通过 ViewModel 将视图中的状态和用户的行为分离出一个抽象</li>
<li>Virtual DOM<br>  // 对比完两棵树以后，就可以通过差异去局部更新 DOM，实现性能的最优化<br>  1.将 Virtual DOM 作为一个兼容层，让我们还能对接非 Web 端的系统，实现跨端开发<br>  2.通过 Virtual DOM 我们可以渲染到其他的平台，比如实现 SSR、同构渲染等<br>  3.实现组件的高度抽象化</li>
<li><p>前端路由<br>  // 监听 URL 的变化，然后匹配路由规则，显示相应的页面，并且无须刷新页面<br>  1.Hash 模式</p>
<pre><code>// 更简单，并且兼容性也更好
window.addEventListener(&apos;hashchange&apos;, () =&gt; {

})
</code></pre><p>  2.History 模式</p>
<pre><code>// history.pushState 和 history.replaceState
// 新增历史记录 history.pushState(stateObject, title, URL)
// 替换当前历史记录 history.replaceState(stateObject, title, URL)
// 点击后退按钮时会触发 popState 事件
window.addEventListener(&apos;popstate&apos;, e =&gt; {
  // e.state 就是 pushState(stateObject) 中的 stateObject
  console.log(e.state)
})
</code></pre></li>
<li><p>Vue</p>
</li>
<li>组件通信<br>  1.父子通信<pre><code>// 单向数据流
// props 传递数据给子组件，子组件不能直接修改 props，必须通过发送事件的方式告知父组件修改数据
// $attrs 属性透传
// emit 发送事件传递数据给父组件
// v-mode 语法糖 默认会解析成名为 value 的 prop 和名为 input 的事件
// 通过访问 $parent 或者 $children 对象来访问组件实例中的方法和数据
// $listeners 属性会将父组件中的 (不含 .native 修饰器的) v-on 事件监听器传递给子组件，子组件可以通过访问 $listeners 来自定义监听器
// .sync 属性是个语法糖
&lt;!--父组件中--&gt;
&lt;input :value.sync=&quot;value&quot; /&gt;
&lt;!--以上写法等同于--&gt;
&lt;input :value=&quot;value&quot; @update:value=&quot;v =&gt; value = v&quot;&gt;&lt;/comp&gt;
&lt;!--子组件中--&gt;
&lt;script&gt;
  this.$emit(&apos;update:value&apos;, 1)
&lt;/script&gt;
</code></pre>  2.兄弟组件通信<pre><code>// 通过查找父组件中的子组件实现 this.$parent.$children
</code></pre>  3.跨多层次组件通信<pre><code>// provide / inject：Vue 2.2 新增的 API
</code></pre>  4.任意组件<pre><code>// Vuex
// Event Bus
</code></pre></li>
<li>Vue.extend()<br>  // 扩展组件生成一个构造器，通常会与 $mount 一起使用</li>
<li>mixin &amp; mixins<br>  // mixin 用于全局混入，会影响到每个组件实例<br>  // mixins 扩展组件的方式，上拉下拉加载数据这种逻辑（先于组件内的钩子函数执行）</li>
<li>computed &amp; watch<br>  // computed 是计算属性，依赖其他属性计算值，并且 computed 的值有缓存，只有当计算值变化才会返回内容<br>  // watch 监听到值的变化就会执行回调，在回调中可以进行一些逻辑操作<br>  // computed 和 watch 还都支持对象的写法</li>
<li>keep-alive<br>  // 保存一些组件的状态防止多次渲染<br>  // 拥有两个独有的生命周期钩子函数，分别为 activated 和 deactivated<br>  // 缓存到内存中并执行 deactivated 钩子函数，命中缓存渲染后会执行 actived 钩子函数</li>
<li>$attrs<br>  // 属性透传，使用起来也比较简单，避免了多写 props</li>
<li>响应式原理<br>  1.Object.defineProperty() getter/setter 劫持了数据的读写操作，使我们可以在数据读写时得到通知并执行自定义的操作<br>  2.递归遍历<br>  3.订阅/发布: Dep 和 Watcher<br>  4.数组的特殊响应化处理 Object.create(Array.prototype)<br>  5.精准依赖收集：为每个键都维护一个 Dep<br>  6.异步更新队列：避免不必要的计算和 DOM 操作（MutationObserver 与 Promise.then 中的回调均在下一个 microTask 中执行）<br>  7.key 的添加与删除（每个 key 对应值为对象/数组创建了另一个 dep，挂在该对象和数组的 <strong>ob</strong> 属性上，setter 操作，通知 set/get 中的 dep；非 setter 操作，如对象 key 添加删除、数组变异方法调用，通知 <strong>ob</strong> 中的 dep）<br>  8.深度数据追踪：递归进去遍历每一个子属性，主动触发一下 getter<br>  9.Proxy：支持监测数组的 push 等方法操作，支持对象属性的动态添加和删除，极大的简化了响应化的代码量<br>  // 依赖收集：在 getter 过程中标记当前的键，仅在被标记的键修改时，才去触发订阅的更新（在键的 getter 触发时将当前 watcher 加入 dep 中，完成依赖收集）<br>  // 简单实现：data-reactivity-system-demo.js<br>  // 通过下标方式修改数组数据或者给对象新增属性并不会触发组件的重新渲染，因为 Object.defineProperty 不能拦截到这些操作，更精确的来说，对于数组而言，大部分操作都是拦截不到的 </li>
<li>编译过程<br>  1.将模板解析为 AST<pre><code>// 基本的 AST 对象
{
  // 类型
  type: 1,
  // 标签
  tag,
  // 属性列表
  attrsList: attrs,
  // 属性映射
  attrsMap: makeAttrsMap(attrs),
  // 父节点
  parent,
  // 子节点
  children: []
}
// 根据这个最基本的 AST 对象中的属性，进一步扩展 AST
</code></pre>  2.优化 AST<pre><code>// 静态内容提取
// 提取静态的属性
</code></pre>  3.将 AST 转换为 render 函数<pre><code>// 历整个 AST，根据不同的条件生成不同的代码
</code></pre></li>
<li><p>nextTick 原理分析<br>  // 本质是 microtask！！<br>  // MutationObserver 和 Promise.then（Vue 2.0.0-rc.7曾尝试用window.postMessage，是macrotask，不可行）<br>  // Vue.nextTick和Vue.prototype.$nextTick都是直接使用了这个nextTick<br>  // 在batcher中，也就是watcher观测到数据变化后执行的是nextTick(flushBatcherQueue)，flushBatcherQueue则负责执行完成所有的dom更新操作<br>  // nextTick 可以让我们在下次 DOM 更新循环结束之后执行延迟回调，用于获得更新后的 DOM<br>  // 在新版本中，会默认使用 microtasks，但在特殊情况下会使用 macrotasks，比如 v-on<br>  // 实现 macrotasks：会先判断是否能使用 setImmediate ，不能的话降级为 MessageChannel ，以上都不行的话就使用 setTimeout<br>  // 最新版的Vue源码里，优先使用Promise.resolve().then(nextTickHandler)来将异步回调放入到microtask中（MO在IOS9.3以上的WebView中有bug），没有原生Promise才用MO<br>  if (typeof setImmediate !== ‘undefined’ &amp;&amp; isNative(setImmediate)) {</p>
<pre><code>macroTimerFunc = () =&gt; {
  setImmediate(flushCallbacks)
}
</code></pre><p>  } else if (</p>
<pre><code>typeof MessageChannel !== &apos;undefined&apos; &amp;&amp;
(isNative(MessageChannel) ||
  // PhantomJS
  MessageChannel.toString() === &apos;[object MessageChannelConstructor]&apos;)
</code></pre><p>  ) {</p>
<pre><code>const channel = new MessageChannel()
const port = channel.port2
channel.port1.onmessage = flushCallbacks
macroTimerFunc = () =&gt; {
  port.postMessage(1)
}
</code></pre><p>  } else {</p>
<pre><code>macroTimerFunc = () =&gt; {
  setTimeout(flushCallbacks, 0)
}
</code></pre><p>  }<br>  // <a href="https://github.com/Ma63d/vue-analysis/issues/6" target="_blank" rel="noopener">https://github.com/Ma63d/vue-analysis/issues/6</a></p>
</li>
<li><p>React<br>  // Fiber 机制（V16）<br>  // 对于异步渲染，现在渲染有两个阶段：reconciliation 和 commit 。前者过程是可以打断的，后者不能暂停，会一直更新界面直到完成。<br>  Reconciliation 阶段</p>
<pre><code>1.componentWillMount
2.componentWillReceiveProps -&gt; getDerivedStateFromProps
3.shouldComponentUpdate
4.componentWillUpdate -&gt; getSnapshotBeforeUpdate
</code></pre><p>  Commit 阶段</p>
<pre><code>1.componentDidMount
2.componentDidUpdate
3.componentWillUnmount
</code></pre><p>setState<br>  // 是个异步 API，多次调用放入一个队列中，在恰当的时候统一进行更新过程<br>  // 如果想实时：<br>  this.setState((prevState) =&gt; ({ count: prevState.count + 1 }), () =&gt; {</p>
<pre><code>console.log(this.state)
</code></pre><p>  })</p>
<p>性能优化<br>  // shouldComponentUpdate 函数中我们可以通过返回布尔值来决定当前组件是否需要更新。这层代码逻辑可以是简单地浅比较一下当前 state 和之前的 state 是否相同，也可以是判断某个值更新了才触发组件更新<br>  // React.PureComponent<br>  // React.memo()</p>
<p>通信<br>  1.父子通信</p>
<pre><code>// 父组件通过 props 传递数据给子组件，子组件通过调用父组件传来的函数传递数据给父组件
// 单向数据流
</code></pre><p>  2.兄弟组件通信</p>
<pre><code>// 通过共同的父组件来管理状态和事件函数
</code></pre><p>  3.跨多层级组件通信</p>
<pre><code>// React.createContext()
</code></pre><p>  4.任意组件</p>
<pre><code>// Redux
// Event Bus
</code></pre><p>高阶组件（HOC）</p>
<p>事件机制<br>  // 合成事件（SyntheticEvent）</p>
<p>Hooks<br>  // 抽离重复逻辑 不会增加组件的嵌套 实现状态的共享<br>  // 通过函数组件的方式去管理状态，并且也能将四散的业务逻辑写成一个个 Hooks 便于复用以及维护<br>  useState<br>  useEffect<br>  useRef<br>  useCallback</p>
</li>
<li>监控<br>  页面埋点<br>  性能监控<pre><code>// performance.getEntriesByType(&apos;navigation&apos;)
// https://www.jianshu.com/p/47a6b7866ba6
</code></pre>  异常监控</li>
<li>UDP<br>  1.面向无连接<pre><code>// 数据报文的搬运工，不会对数据报文进行任何拆分和拼接操作
// 在发送端，应用层将数据传递给传输层的 UDP 协议，UDP 只会给数据增加一个 UDP 头标识下是 UDP 协议，然后就传递给网络层了
// 在接收端，网络层将数据传递给传输层，UDP 只去除 IP 报文头就传递给应用层，不会任何拼接操作
</code></pre>  2.不可靠性<pre><code>// 某些实时性要求高的场景（比如电话会议）就需要使用 UDP 而不是 TCP
</code></pre>  3.高效<pre><code>// UDP 的头部开销小，只有八字节，相比 TCP 的至少二十字节要少得多，在传输数据报文时是很高效的
</code></pre>  4.传输方式<pre><code>// UDP 不止支持一对一的传输方式，同样支持一对多，多对多，多对一的方式，也就是说 UDP 提供了单播，多播，广播的功能
</code></pre></li>
<li>HTTP/2<br>  1.二进制传输<br>  2.多路复用 帧（frame）和流（stream）<br>  3.Header 压缩<br>  4.服务端 Push<br>  5.</li>
<li>HTTP/3<br>  QUIC<pre><code>多路复用
0-RTT
纠错机制
</code></pre>// HTTP/2 通过多路复用、二进制流、Header 压缩等等技术，极大地提高了性能，但是还是存在着问题的<br>// QUIC 基于 UDP 实现，是 HTTP/3 中的底层支撑协议，该协议基于 UDP，又取了 TCP 中的精华，实现了即快又可靠的协议</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br><span class="line">296</span><br><span class="line">297</span><br><span class="line">298</span><br><span class="line">299</span><br><span class="line">300</span><br><span class="line">301</span><br><span class="line">302</span><br><span class="line">303</span><br><span class="line">304</span><br><span class="line">305</span><br><span class="line">306</span><br><span class="line">307</span><br><span class="line">308</span><br><span class="line">309</span><br><span class="line">310</span><br><span class="line">311</span><br><span class="line">312</span><br><span class="line">313</span><br><span class="line">314</span><br><span class="line">315</span><br><span class="line">316</span><br><span class="line">317</span><br><span class="line">318</span><br><span class="line">319</span><br><span class="line">320</span><br><span class="line">321</span><br><span class="line">322</span><br><span class="line">323</span><br><span class="line">324</span><br><span class="line">325</span><br><span class="line">326</span><br><span class="line">327</span><br><span class="line">328</span><br><span class="line">329</span><br><span class="line">330</span><br><span class="line">331</span><br><span class="line">332</span><br><span class="line">333</span><br><span class="line">334</span><br><span class="line">335</span><br><span class="line">336</span><br><span class="line">337</span><br><span class="line">338</span><br><span class="line">339</span><br><span class="line">340</span><br><span class="line">341</span><br><span class="line">342</span><br><span class="line">343</span><br><span class="line">344</span><br><span class="line">345</span><br><span class="line">346</span><br><span class="line">347</span><br><span class="line">348</span><br><span class="line">349</span><br><span class="line">350</span><br><span class="line">351</span><br><span class="line">352</span><br><span class="line">353</span><br><span class="line">354</span><br><span class="line">355</span><br><span class="line">356</span><br><span class="line">357</span><br><span class="line">358</span><br><span class="line">359</span><br><span class="line">360</span><br><span class="line">361</span><br><span class="line">362</span><br><span class="line">363</span><br><span class="line">364</span><br><span class="line">365</span><br><span class="line">366</span><br><span class="line">367</span><br><span class="line">368</span><br><span class="line">369</span><br><span class="line">370</span><br><span class="line">371</span><br><span class="line">372</span><br><span class="line">373</span><br><span class="line">374</span><br><span class="line">375</span><br><span class="line">376</span><br><span class="line">377</span><br><span class="line">378</span><br><span class="line">379</span><br><span class="line">380</span><br><span class="line">381</span><br><span class="line">382</span><br><span class="line">383</span><br><span class="line">384</span><br><span class="line">385</span><br><span class="line">386</span><br><span class="line">387</span><br><span class="line">388</span><br><span class="line">389</span><br><span class="line">390</span><br><span class="line">391</span><br><span class="line">392</span><br><span class="line">393</span><br><span class="line">394</span><br><span class="line">395</span><br><span class="line">396</span><br><span class="line">397</span><br><span class="line">398</span><br><span class="line">399</span><br><span class="line">400</span><br><span class="line">401</span><br><span class="line">402</span><br><span class="line">403</span><br><span class="line">404</span><br><span class="line">405</span><br><span class="line">406</span><br><span class="line">407</span><br><span class="line">408</span><br><span class="line">409</span><br><span class="line">410</span><br><span class="line">411</span><br><span class="line">412</span><br><span class="line">413</span><br><span class="line">414</span><br><span class="line">415</span><br><span class="line">416</span><br><span class="line">417</span><br><span class="line">418</span><br><span class="line">419</span><br><span class="line">420</span><br><span class="line">421</span><br><span class="line">422</span><br><span class="line">423</span><br><span class="line">424</span><br><span class="line">425</span><br><span class="line">426</span><br><span class="line">427</span><br><span class="line">428</span><br><span class="line">429</span><br><span class="line">430</span><br><span class="line">431</span><br><span class="line">432</span><br><span class="line">433</span><br><span class="line">434</span><br><span class="line">435</span><br><span class="line">436</span><br><span class="line">437</span><br><span class="line">438</span><br><span class="line">439</span><br><span class="line">440</span><br><span class="line">441</span><br><span class="line">442</span><br><span class="line">443</span><br><span class="line">444</span><br><span class="line">445</span><br><span class="line">446</span><br><span class="line">447</span><br><span class="line">448</span><br><span class="line">449</span><br><span class="line">450</span><br><span class="line">451</span><br><span class="line">452</span><br><span class="line">453</span><br><span class="line">454</span><br><span class="line">455</span><br><span class="line">456</span><br><span class="line">457</span><br><span class="line">458</span><br><span class="line">459</span><br><span class="line">460</span><br><span class="line">461</span><br><span class="line">462</span><br><span class="line">463</span><br><span class="line">464</span><br><span class="line">465</span><br><span class="line">466</span><br><span class="line">467</span><br><span class="line">468</span><br><span class="line">469</span><br><span class="line">470</span><br><span class="line">471</span><br><span class="line">472</span><br><span class="line">473</span><br></pre></td><td class="code"><pre><span class="line">* 设计模式</span><br><span class="line">   工厂模式：隐藏了创建实例的复杂度，只需要提供一个接口</span><br><span class="line">   单例模式：保证全局只有一个对象可以访问</span><br><span class="line">   适配器模式：用来解决两个接口不兼容的情况，不需要改变已有的接口，通过包装一层的方式实现两个接口的正常协作</span><br><span class="line">   装饰模式：不需要改变已有的接口，作用是给对象添加功能</span><br><span class="line">   代理模式：控制对对象的访问，不让外部直接访问到对象</span><br><span class="line">   发布/订阅模式（观察者模式）：通过一对一或者一对多的依赖关系，当对象发生改变时，订阅方都会收到通知</span><br><span class="line">   外观模式：提供了一个接口，隐藏了内部的逻辑，更加方便外部调用</span><br><span class="line">   策略模式：</span><br><span class="line">* 数据结构</span><br><span class="line">    栈：线性结构，只能在某一端添加或删除数据，遵循先进后出的原则</span><br><span class="line">    队列：线性结构，特点是在某一端添加数据，在另一端删除数据，遵循先进先出的原则</span><br><span class="line">      单链队列：</span><br><span class="line">        class Queue &#123;</span><br><span class="line">          constructor() &#123;</span><br><span class="line">            this.queue = []</span><br><span class="line">          &#125;</span><br><span class="line">          enQueue(item) &#123;</span><br><span class="line">            this.queue.push(item)</span><br><span class="line">          &#125;</span><br><span class="line">          deQueue() &#123;</span><br><span class="line">            return this.queue.shift()</span><br><span class="line">          &#125;</span><br><span class="line">          getHeader() &#123;</span><br><span class="line">            return this.queue[0]</span><br><span class="line">          &#125;</span><br><span class="line">          getLength() &#123;</span><br><span class="line">            return this.queue.length</span><br><span class="line">          &#125;</span><br><span class="line">          isEmpty() &#123;</span><br><span class="line">            return this.getLength() === 0</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      循环队列：单链队列在出队操作的时候需要 O(n) 的时间复杂度，所以引入了循环队列。循环队列的出队操作平均是 O(1) 的时间复杂度</span><br><span class="line">        class SqQueue &#123;</span><br><span class="line">          constructor(length) &#123;</span><br><span class="line">            this.queue = new Array(length + 1)</span><br><span class="line">            // 队头</span><br><span class="line">            this.first = 0</span><br><span class="line">            // 队尾</span><br><span class="line">            this.last = 0</span><br><span class="line">            // 当前队列大小</span><br><span class="line">            this.size = 0</span><br><span class="line">          &#125;</span><br><span class="line">          enQueue(item) &#123;</span><br><span class="line">            // 判断队尾 + 1 是否为队头</span><br><span class="line">            // 如果是就代表需要扩容数组</span><br><span class="line">            // % this.queue.length 是为了防止数组越界</span><br><span class="line">            if (this.first === (this.last + 1) % this.queue.length) &#123;</span><br><span class="line">              this.resize(this.getLength() * 2 + 1)</span><br><span class="line">            &#125;</span><br><span class="line">            this.queue[this.last] = item</span><br><span class="line">            this.size++</span><br><span class="line">            this.last = (this.last + 1) % this.queue.length</span><br><span class="line">          &#125;</span><br><span class="line">          deQueue() &#123;</span><br><span class="line">            if (this.isEmpty()) &#123;</span><br><span class="line">              throw Error(&apos;Queue is empty&apos;)</span><br><span class="line">            &#125;</span><br><span class="line">            let r = this.queue[this.first]</span><br><span class="line">            this.queue[this.first] = null</span><br><span class="line">            this.first = (this.first + 1) % this.queue.length</span><br><span class="line">            this.size--</span><br><span class="line">            // 判断当前队列大小是否过小</span><br><span class="line">            // 为了保证不浪费空间，在队列空间等于总长度四分之一时</span><br><span class="line">            // 且不为 2 时缩小总长度为当前的一半</span><br><span class="line">            if (this.size === this.getLength() / 4 &amp;&amp; this.getLength() / 2 !== 0) &#123;</span><br><span class="line">              this.resize(this.getLength() / 2)</span><br><span class="line">            &#125;</span><br><span class="line">            return r</span><br><span class="line">          &#125;</span><br><span class="line">          getHeader() &#123;</span><br><span class="line">            if (this.isEmpty()) &#123;</span><br><span class="line">              throw Error(&apos;Queue is empty&apos;)</span><br><span class="line">            &#125;</span><br><span class="line">            return this.queue[this.first]</span><br><span class="line">          &#125;</span><br><span class="line">          getLength() &#123;</span><br><span class="line">            return this.queue.length - 1</span><br><span class="line">          &#125;</span><br><span class="line">          isEmpty() &#123;</span><br><span class="line">            return this.first === this.last</span><br><span class="line">          &#125;</span><br><span class="line">          resize(length) &#123;</span><br><span class="line">            let q = new Array(length)</span><br><span class="line">            for (let i = 0; i &lt; length; i++) &#123;</span><br><span class="line">              q[i] = this.queue[(i + this.first) % this.queue.length]</span><br><span class="line">            &#125;</span><br><span class="line">            this.queue = q</span><br><span class="line">            this.first = 0</span><br><span class="line">            this.last = this.size</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    链表：是一个线性结构，同时也是一个天然的递归结构。链表结构可以充分利用计算机内存空间，实现灵活的内存动态管理。但是链表失去了数组随机读取的优点，同时链表由于增加了结点的指针域，空间开销比较大</span><br><span class="line">      单向链表：</span><br><span class="line">        class Node &#123;</span><br><span class="line">          constructor(v, next) &#123;</span><br><span class="line">            this.value = v</span><br><span class="line">            this.next = next</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        class LinkList &#123;</span><br><span class="line">          constructor() &#123;</span><br><span class="line">            // 链表长度</span><br><span class="line">            this.size = 0</span><br><span class="line">            // 虚拟头部</span><br><span class="line">            this.dummyNode = new Node(null, null)</span><br><span class="line">          &#125;</span><br><span class="line">          find(header, index, currentIndex) &#123;</span><br><span class="line">            if (index === currentIndex) return header</span><br><span class="line">            return this.find(header.next, index, currentIndex + 1)</span><br><span class="line">          &#125;</span><br><span class="line">          addNode(v, index) &#123;</span><br><span class="line">            this.checkIndex(index)</span><br><span class="line">            // 当往链表末尾插入时，prev.next 为空</span><br><span class="line">            // 其他情况时，因为要插入节点，所以插入的节点</span><br><span class="line">            // 的 next 应该是 prev.next</span><br><span class="line">            // 然后设置 prev.next 为插入的节点</span><br><span class="line">            let prev = this.find(this.dummyNode, index, 0)</span><br><span class="line">            prev.next = new Node(v, prev.next)</span><br><span class="line">            this.size++</span><br><span class="line">            return prev.next</span><br><span class="line">          &#125;</span><br><span class="line">          insertNode(v, index) &#123;</span><br><span class="line">            return this.addNode(v, index)</span><br><span class="line">          &#125;</span><br><span class="line">          addToFirst(v) &#123;</span><br><span class="line">            return this.addNode(v, 0)</span><br><span class="line">          &#125;</span><br><span class="line">          addToLast(v) &#123;</span><br><span class="line">            return this.addNode(v, this.size)</span><br><span class="line">          &#125;</span><br><span class="line">          removeNode(index, isLast) &#123;</span><br><span class="line">            this.checkIndex(index)</span><br><span class="line">            index = isLast ? index - 1 : index</span><br><span class="line">            let prev = this.find(this.dummyNode, index, 0)</span><br><span class="line">            let node = prev.next</span><br><span class="line">            prev.next = node.next</span><br><span class="line">            node.next = null</span><br><span class="line">            this.size--</span><br><span class="line">            return node</span><br><span class="line">          &#125;</span><br><span class="line">          removeFirstNode() &#123;</span><br><span class="line">            return this.removeNode(0)</span><br><span class="line">          &#125;</span><br><span class="line">          removeLastNode() &#123;</span><br><span class="line">            return this.removeNode(this.size, true)</span><br><span class="line">          &#125;</span><br><span class="line">          checkIndex(index) &#123;</span><br><span class="line">            if (index &lt; 0 || index &gt; this.size) throw Error(&apos;Index error&apos;)</span><br><span class="line">          &#125;</span><br><span class="line">          getNode(index) &#123;</span><br><span class="line">            this.checkIndex(index)</span><br><span class="line">            if (this.isEmpty()) return</span><br><span class="line">            return this.find(this.dummyNode, index, 0).next</span><br><span class="line">          &#125;</span><br><span class="line">          isEmpty() &#123;</span><br><span class="line">            return this.size === 0</span><br><span class="line">          &#125;</span><br><span class="line">          getSize() &#123;</span><br><span class="line">            return this.size</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    树：</span><br><span class="line">      二叉树：天然的递归结构，拥有一个根节点，每个节点至多拥有两个子节点，分别为：左节点和右节点。树的最底部节点称之为叶节点，当一颗树的叶数量为满时，该树可以称之为满二叉树。</span><br><span class="line">      二分搜索树：二分搜索树也是二叉树，拥有二叉树的特性。但是区别在于二分搜索树每个节点的值都比他的左子树的值大，比右子树的值小。这种存储方式很适合于数据搜索。</span><br><span class="line">      AVL 树：AVL 树改进了二分搜索树，在 AVL 树中任意节点的左右子树的高度差都不大于 1，这样保证了时间复杂度是严格的 O(logN)。基于此，对 AVL 树增加或删除节点时可能需要旋转树来达到高度的平衡。</span><br><span class="line">      Trie：又称前缀树或字典树，是一种有序树，用于保存关联数组，其中的键通常是字符串。</span><br><span class="line">      并查集：一种特殊的树结构，用于处理一些不交集的合并及查询问题。该结构中每个节点都有一个父节点，如果只有当前一个节点，那么该节点的父节点指向自己。</span><br><span class="line">        Find：确定元素属于哪一个子集。它可以被用来确定两个元素是否属于同一子集。</span><br><span class="line">        Union：将两个子集合并成同一个集合。</span><br><span class="line">    堆：通常是一个可以被看做一棵树的数组对象。堆的实现通过构造二叉堆，实为二叉树的一种。</span><br><span class="line">* 算法</span><br><span class="line">    按位操作</span><br><span class="line">      按位与</span><br><span class="line">      按位或</span><br><span class="line">      按位异或</span><br><span class="line">    排序</span><br><span class="line">      冒泡排序</span><br><span class="line">        function bubble(array) &#123;</span><br><span class="line">          checkArray(array);</span><br><span class="line">          for (let i = array.length - 1; i &gt; 0; i--) &#123;</span><br><span class="line">            // 从 0 到 `length - 1` 遍历</span><br><span class="line">            for (let j = 0; j &lt; i; j++) &#123;</span><br><span class="line">              if (array[j] &gt; array[j + 1]) swap(array, j, j + 1)</span><br><span class="line">            &#125;</span><br><span class="line">          &#125;</span><br><span class="line">          return array;</span><br><span class="line">        &#125;</span><br><span class="line">      插入排序</span><br><span class="line">        function insertion(array) &#123;</span><br><span class="line">          if (!checkArray(array)) return</span><br><span class="line">          for (let i = 1; i &lt; array.length; i++) &#123;</span><br><span class="line">            for (let j = i - 1; j &gt;= 0 &amp;&amp; array[j] &gt; array[j + 1]; j--)</span><br><span class="line">              swap(array, j, j + 1);</span><br><span class="line">          &#125;</span><br><span class="line">          return array;</span><br><span class="line">        &#125;</span><br><span class="line">      选择排序</span><br><span class="line">        function selection(array) &#123;</span><br><span class="line">          if (!checkArray(array)) return</span><br><span class="line">          for (let i = 0; i &lt; array.length - 1; i++) &#123;</span><br><span class="line">            let minIndex = i;</span><br><span class="line">            for (let j = i + 1; j &lt; array.length; j++) &#123;</span><br><span class="line">              minIndex = array[j] &lt; array[minIndex] ? j : minIndex;</span><br><span class="line">            &#125;</span><br><span class="line">            swap(array, i, minIndex);</span><br><span class="line">          &#125;</span><br><span class="line">          return array;</span><br><span class="line">        &#125;</span><br><span class="line">      归并排序</span><br><span class="line">        function sort(array) &#123;</span><br><span class="line">          if (!checkArray(array)) return</span><br><span class="line">          mergeSort(array, 0, array.length - 1);</span><br><span class="line">          return array;</span><br><span class="line">        &#125;</span><br><span class="line">        function mergeSort(array, left, right) &#123;</span><br><span class="line">          // 左右索引相同说明已经只有一个数</span><br><span class="line">          if (left === right) return;</span><br><span class="line">          // 等同于 `left + (right - left) / 2`</span><br><span class="line">          // 相比 `(left + right) / 2` 来说更加安全，不会溢出</span><br><span class="line">          // 使用位运算是因为位运算比四则运算快</span><br><span class="line">          let mid = parseInt(left + ((right - left) &gt;&gt; 1));</span><br><span class="line">          mergeSort(array, left, mid);</span><br><span class="line">          mergeSort(array, mid + 1, right);</span><br><span class="line"></span><br><span class="line">          let help = [];</span><br><span class="line">          let i = 0;</span><br><span class="line">          let p1 = left;</span><br><span class="line">          let p2 = mid + 1;</span><br><span class="line">          while (p1 &lt;= mid &amp;&amp; p2 &lt;= right) &#123;</span><br><span class="line">            help[i++] = array[p1] &lt; array[p2] ? array[p1++] : array[p2++];</span><br><span class="line">          &#125;</span><br><span class="line">          while (p1 &lt;= mid) &#123;</span><br><span class="line">            help[i++] = array[p1++];</span><br><span class="line">          &#125;</span><br><span class="line">          while (p2 &lt;= right) &#123;</span><br><span class="line">            help[i++] = array[p2++];</span><br><span class="line">          &#125;</span><br><span class="line">          for (let i = 0; i &lt; help.length; i++) &#123;</span><br><span class="line">            array[left + i] = help[i];</span><br><span class="line">          &#125;</span><br><span class="line">          return array;</span><br><span class="line">        &#125;</span><br><span class="line">      快速排序</span><br><span class="line">        function sort(array) &#123;</span><br><span class="line">          if (!checkArray(array)) return</span><br><span class="line">          quickSort(array, 0, array.length - 1);</span><br><span class="line">          return array;</span><br><span class="line">        &#125;</span><br><span class="line">        function quickSort(array, left, right) &#123;</span><br><span class="line">          if (left &lt; right) &#123;</span><br><span class="line">            swap(array, , right)</span><br><span class="line">            // 随机取值，然后和末尾交换，这样做比固定取一个位置的复杂度略低</span><br><span class="line">            let indexs = part(array, parseInt(Math.random() * (right - left + 1)) + left, right);</span><br><span class="line">            quickSort(array, left, indexs[0]);</span><br><span class="line">            quickSort(array, indexs[1] + 1, right);</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        function part(array, left, right) &#123;</span><br><span class="line">          let less = left - 1;</span><br><span class="line">          let more = right;</span><br><span class="line">          while (left &lt; more) &#123;</span><br><span class="line">            if (array[left] &lt; array[right]) &#123;</span><br><span class="line">              // 当前值比基准值小，`less` 和 `left` 都加一</span><br><span class="line">             ++less;</span><br><span class="line">               ++left;</span><br><span class="line">            &#125; else if (array[left] &gt; array[right]) &#123;</span><br><span class="line">              // 当前值比基准值大，将当前值和右边的值交换</span><br><span class="line">              // 并且不改变 `left`，因为当前换过来的值还没有判断过大小</span><br><span class="line">              swap(array, --more, left);</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">              // 和基准值相同，只移动下标</span><br><span class="line">              left++;</span><br><span class="line">            &#125;</span><br><span class="line">          &#125;</span><br><span class="line">          // 将基准值和比基准值大的第一个值交换位置</span><br><span class="line">          // 这样数组就变成 `[比基准值小, 基准值, 比基准值大]`</span><br><span class="line">          swap(array, right, more);</span><br><span class="line">          return [less, more];</span><br><span class="line">        &#125;</span><br><span class="line">      堆排序</span><br><span class="line">        堆排序利用了二叉堆的特性来做，二叉堆通常用数组表示，并且二叉堆是一颗完全二叉树（所有叶节点（最底层的节点）都是从左往右顺序排序，并且其他层的节点都是满的）。二叉堆又分为大根堆与小根堆。</span><br><span class="line">          1.大根堆是某个节点的所有子节点的值都比他小</span><br><span class="line">          2.小根堆是某个节点的所有子节点的值都比他大</span><br><span class="line">        堆排序的原理就是组成一个大根堆或者小根堆。以小根堆为例，某个节点的左边子节点索引是 i * 2 + 1，右边是 i * 2 + 2，父节点是 (i - 1) /2。</span><br><span class="line">          1.首先遍历数组，判断该节点的父节点是否比他小，如果小就交换位置并继续判断，直到他的父节点比他大</span><br><span class="line">          2.重新以上操作 1，直到数组首位是最大值</span><br><span class="line">          3.然后将首位和末尾交换位置并将数组长度减一，表示数组末尾已是最大值，不需要再比较大小</span><br><span class="line">          4.对比左右节点哪个大，然后记住大的节点的索引并且和父节点对比大小，如果子节点大就交换位置</span><br><span class="line">          5.重复以上操作 3 - 4 直到整个数组都是大根堆。</span><br><span class="line">        function heap(array) &#123;</span><br><span class="line">          if (!checkArray(array)) return</span><br><span class="line">          // 将最大值交换到首位</span><br><span class="line">          for (let i = 0; i &lt; array.length; i++) &#123;</span><br><span class="line">            heapInsert(array, i);</span><br><span class="line">          &#125;</span><br><span class="line">          let size = array.length;</span><br><span class="line">          // 交换首位和末尾</span><br><span class="line">          swap(array, 0, --size);</span><br><span class="line">          while (size &gt; 0) &#123;</span><br><span class="line">            heapify(array, 0, size);</span><br><span class="line">            swap(array, 0, --size);</span><br><span class="line">          &#125;</span><br><span class="line">          return array;</span><br><span class="line">        &#125;</span><br><span class="line">        function heapInsert(array, index) &#123;</span><br><span class="line">          // 如果当前节点比父节点大，就交换</span><br><span class="line">          while (array[index] &gt; array[parseInt((index - 1) / 2)]) &#123;</span><br><span class="line">            swap(array, index, parseInt((index - 1) / 2));</span><br><span class="line">            // 将索引变成父节点</span><br><span class="line">            index = parseInt((index - 1) / 2);</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        function heapify(array, index, size) &#123;</span><br><span class="line">          let left = index * 2 + 1;</span><br><span class="line">          while (left &lt; size) &#123;</span><br><span class="line">            // 判断左右节点大小</span><br><span class="line">            let largest =</span><br><span class="line">              left + 1 &lt; size &amp;&amp; array[left] &lt; array[left + 1] ? left + 1 : left;</span><br><span class="line">            // 判断子节点和父节点大小</span><br><span class="line">            largest = array[index] &lt; array[largest] ? largest : index;</span><br><span class="line">            if (largest === index) break;</span><br><span class="line">            swap(array, index, largest);</span><br><span class="line">            index = largest;</span><br><span class="line">            left = index * 2 + 1;</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    链表</span><br><span class="line">      反转单向链表</span><br><span class="line">        var reverseList = function(head) &#123;</span><br><span class="line">          // 判断下变量边界问题</span><br><span class="line">          if (!head || !head.next) return head</span><br><span class="line">          // 初始设置为空，因为第一个节点反转后就是尾部，尾部节点指向 null</span><br><span class="line">          let pre = null</span><br><span class="line">          let current = head</span><br><span class="line">          let next</span><br><span class="line">          // 判断当前节点是否为空</span><br><span class="line">          // 不为空就先获取当前节点的下一节点</span><br><span class="line">          // 然后把当前节点的 next 设为上一个节点</span><br><span class="line">          // 然后把 current 设为下一个节点，pre 设为当前节点</span><br><span class="line">          while(current) &#123;</span><br><span class="line">              next = current.next</span><br><span class="line">              current.next = pre</span><br><span class="line">              pre = current</span><br><span class="line">              current = next</span><br><span class="line">          &#125;</span><br><span class="line">          return pre</span><br><span class="line">        &#125;;</span><br><span class="line">    树</span><br><span class="line">      先序遍历表示先访问根节点，然后访问左节点，最后访问右节点。</span><br><span class="line">      中序遍历表示先访问左节点，然后访问根节点，最后访问右节点。</span><br><span class="line">      后序遍历表示先访问左节点，然后访问右节点，最后访问根节点。</span><br><span class="line">      递归实现</span><br><span class="line">        function TreeNode(val) &#123;</span><br><span class="line">          this.val = val;</span><br><span class="line">          this.left = this.right = null;</span><br><span class="line">        &#125;</span><br><span class="line">        var traversal = function(root) &#123;</span><br><span class="line">          if (root) &#123;</span><br><span class="line">            // 先序</span><br><span class="line">            console.log(root); </span><br><span class="line">            traversal(root.left);</span><br><span class="line">            // 中序</span><br><span class="line">            // console.log(root); </span><br><span class="line">            traversal(root.right);</span><br><span class="line">            // 后序</span><br><span class="line">            // console.log(root);</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">      非递归实现</span><br><span class="line">        非递归实现使用了栈的结构，通过栈的先进后出模拟递归实现。</span><br><span class="line">        // 先序遍历代码实现</span><br><span class="line">        function pre(root) &#123;</span><br><span class="line">          if (root) &#123;</span><br><span class="line">            let stack = [];</span><br><span class="line">            // 先将根节点 push</span><br><span class="line">            stack.push(root);</span><br><span class="line">            // 判断栈中是否为空</span><br><span class="line">            while (stack.length &gt; 0) &#123;</span><br><span class="line">              // 弹出栈顶元素</span><br><span class="line">              root = stack.pop();</span><br><span class="line">              console.log(root);</span><br><span class="line">              // 因为先序遍历是先左后右，栈是先进后出结构</span><br><span class="line">              // 所以先 push 右边再 push 左边</span><br><span class="line">              if (root.right) &#123;</span><br><span class="line">                stack.push(root.right);</span><br><span class="line">              &#125;</span><br><span class="line">              if (root.left) &#123;</span><br><span class="line">                stack.push(root.left);</span><br><span class="line">              &#125;</span><br><span class="line">            &#125;</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        // 中序遍历代码实现</span><br><span class="line">        function mid(root) &#123;</span><br><span class="line">          if (root) &#123;</span><br><span class="line">            let stack = [];</span><br><span class="line">            // 中序遍历是先左再根最后右</span><br><span class="line">            // 所以首先应该先把最左边节点遍历到底依次 push 进栈</span><br><span class="line">            // 当左边没有节点时，就打印栈顶元素，然后寻找右节点</span><br><span class="line">            // 对于最左边的叶节点来说，可以把它看成是两个 null 节点的父节点</span><br><span class="line">            // 左边打印不出东西就把父节点拿出来打印，然后再看右节点</span><br><span class="line">            while (stack.length &gt; 0 || root) &#123;</span><br><span class="line">              if (root) &#123;</span><br><span class="line">                stack.push(root);</span><br><span class="line">                root = root.left;</span><br><span class="line">              &#125; else &#123;</span><br><span class="line">                root = stack.pop();</span><br><span class="line">                console.log(root);</span><br><span class="line">                root = root.right;</span><br><span class="line">              &#125;</span><br><span class="line">            &#125;</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        // 后序遍历代码实现</span><br><span class="line">        // 该代码使用了两个栈来实现遍历，相比一个栈的遍历来说要容易理解很多</span><br><span class="line">        function pos(root) &#123;</span><br><span class="line">          if (root) &#123;</span><br><span class="line">            let stack1 = [];</span><br><span class="line">            let stack2 = [];</span><br><span class="line">            // 后序遍历是先左再右最后根</span><br><span class="line">          // 所以对于一个栈来说，应该先 push 根节点</span><br><span class="line">            // 然后 push 右节点，最后 push 左节点</span><br><span class="line">            stack1.push(root);</span><br><span class="line">            while (stack1.length &gt; 0) &#123;</span><br><span class="line">              root = stack1.pop();</span><br><span class="line">              stack2.push(root);</span><br><span class="line">              if (root.left) &#123;</span><br><span class="line">                stack1.push(root.left);</span><br><span class="line">              &#125;</span><br><span class="line">              if (root.right) &#123;</span><br><span class="line">                stack1.push(root.right);</span><br><span class="line">              &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            while (stack2.length &gt; 0) &#123;</span><br><span class="line">              console.log(s2.pop());</span><br><span class="line">            &#125;</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      树的深度</span><br><span class="line">        树的最大深度</span><br><span class="line">          var maxDepth = function(root) &#123;</span><br><span class="line">            if (!root) return 0</span><br><span class="line">            return Math.max(maxDepth(root.left), maxDepth(root.right)) + 1</span><br><span class="line">          &#125;;</span><br><span class="line">      动态规划</span><br><span class="line">        1.自底向上分解子问题</span><br><span class="line">        2.通过变量存储已经计算过的解</span><br><span class="line">        function fib(n) &#123;</span><br><span class="line">          let array = new Array(n + 1).fill(null)</span><br><span class="line">          array[0] = 0</span><br><span class="line">          array[1] = 1</span><br><span class="line">          for (let i = 2; i &lt;= n; i++) &#123;</span><br><span class="line">            array[i] = array[i - 1] + array[i - 2]</span><br><span class="line">          &#125;</span><br><span class="line">          return array[n]</span><br><span class="line">        &#125;</span><br><span class="line">        fib(10)</span><br><span class="line">      0-1 背包问题</span><br><span class="line">      最长递增子序列</span><br><span class="line">* CSS</span><br><span class="line">    // https://segmentfault.com/a/1190000013860482</span><br><span class="line">    // https://github.com/AllThingsSmitty/css-protips</span><br><span class="line">    // https://github.com/chokcoco/iCSS</span><br><span class="line">    // https://github.com/30-seconds/30-seconds-of-css</span><br><span class="line">* JS</span><br><span class="line">    // https://github.com/getify/Functional-Light-JS</span><br><span class="line">    // https://github.com/leonardomso/33-js-concepts</span><br><span class="line">    // https://github.com/dt-fe/weekly</span><br><span class="line">    // https://github.com/JohnsenZhou/Front-End-Performance-Checklist</span><br><span class="line">    // https://github.com/AllThingsSmitty/must-watch-javascript</span><br><span class="line">    // https://github.com/30-seconds/30-seconds-of-code</span><br></pre></td></tr></table></figure>
      
    </div>

    <div>
      
        

      
    </div>

    <div>
      
        
  <div style="padding: 10px 0; margin: 20px auto; width: 90%; text-align: center;">
    <div>坚持原创技术分享，您的支持将鼓励我继续创作！</div>
    <button id="rewardButton" disable="enable" onclick="var qr = document.getElementById('QR'); if (qr.style.display === 'none') {qr.style.display='block';} else {qr.style.display='none'}">
      <span>赏</span>
    </button>
    <div id="QR" style="display: none;">
      
        <div id="wechat" style="display: inline-block">
          <img id="wechat_qr" src="/images/wechat-reward-image.png" alt="Marico WeChat Pay">
          <p>微信打赏</p>
        </div>
      
      
        <div id="alipay" style="display: inline-block">
          <img id="alipay_qr" src="/images/alipay-reward-image.png" alt="Marico Alipay">
          <p>支付宝打赏</p>
        </div>
      
    </div>
  </div>


      
    </div>

    <footer class="post-footer">
      
        <div class="post-tags">
          
            <a href="/tags/年度总结/" rel="tag">#年度总结</a>
          
        </div>
      

      
        <div class="post-nav">
          <div class="post-nav-next post-nav-item">
            
              <a href="/2019/01/03/webpack-bundler-demo-2/" rel="next" title="webpack-bundler-demo-2">
                <i class="fa fa-chevron-left"></i> webpack-bundler-demo-2
              </a>
            
          </div>

          <div class="post-nav-prev post-nav-item">
            
          </div>
        </div>
      

      
      
    </footer>
  </article>



    <div class="post-spread">
      
        <div class="ds-share flat" data-thread-key="2019/12/22/2019 Year in Review/" data-title="2019 Year in Review" data-content data-url="http://yoursite.com/2019/12/22/2019 Year in Review/">
  <div class="ds-share-inline">
    <ul class="ds-share-icons-16">

      <li data-toggle="ds-share-icons-more"><a class="ds-more" href="javascript:void(0);">分享到：</a></li>
      <li><a class="ds-weibo" href="javascript:void(0);" data-service="weibo">微博</a></li>
      <li><a class="ds-qzone" href="javascript:void(0);" data-service="qzone">QQ空间</a></li>
      <li><a class="ds-qqt" href="javascript:void(0);" data-service="qqt">腾讯微博</a></li>
      <li><a class="ds-wechat" href="javascript:void(0);" data-service="wechat">微信</a></li>

    </ul>
    <div class="ds-share-icons-more">
    </div>
  </div>
</div>
      
    </div>
  </div>


          </div>
          


          
  <div class="comments" id="comments">
    
      <div class="ds-thread" data-thread-key="2019/12/22/2019 Year in Review/" data-title="2019 Year in Review" data-url="http://yoursite.com/2019/12/22/2019 Year in Review/">
      </div>
    
  </div>


        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    <div class="sidebar-inner">

      

      
        <ul class="sidebar-nav motion-element">
          <li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap">
            文章目录
          </li>
          <li class="sidebar-nav-overview" data-target="site-overview">
            站点概览
          </li>
        </ul>
      

      <section class="site-overview sidebar-panel ">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
          <img class="site-author-image" itemprop="image" src="/images/avatar.png" alt="Marico">
          <p class="site-author-name" itemprop="name">Marico</p>
          <p class="site-description motion-element" itemprop="description">Front-End Developer</p>
        </div>
        <nav class="site-state motion-element">
          <div class="site-state-item site-state-posts">
            <a href="/archives">
              <span class="site-state-item-count">20</span>
              <span class="site-state-item-name">日志</span>
            </a>
          </div>

          
            <div class="site-state-item site-state-categories">
              <a href="/categories">
                <span class="site-state-item-count">13</span>
                <span class="site-state-item-name">分类</span>
              </a>
            </div>
          

          
            <div class="site-state-item site-state-tags">
              <a href="/tags">
                <span class="site-state-item-count">18</span>
                <span class="site-state-item-name">标签</span>
              </a>
            </div>
          

        </nav>

        

        <div class="links-of-author motion-element">
          
            
              <span class="links-of-author-item">
                <a href="https://github.com/mayue2015" target="_blank" title="GitHub">
                  
                    <i class="fa fa-fw fa-github"></i>
                  
                  GitHub
                </a>
              </span>
            
              <span class="links-of-author-item">
                <a href="http://stackoverflow.com/users/5566587/marico" target="_blank" title="Stack Overflow">
                  
                    <i class="fa fa-fw fa-globe"></i>
                  
                  Stack Overflow
                </a>
              </span>
            
              <span class="links-of-author-item">
                <a href="http://weibo.com/u/2089711385?is_all=1" target="_blank" title="微博">
                  
                    <i class="fa fa-fw fa-globe"></i>
                  
                  微博
                </a>
              </span>
            
              <span class="links-of-author-item">
                <a href="https://twitter.com/MaYueMarico" target="_blank" title="Twitter">
                  
                    <i class="fa fa-fw fa-twitter"></i>
                  
                  Twitter
                </a>
              </span>
            
          
        </div>

        
        

        
        

      </section>

      
        <section class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active">
          <div class="post-toc">
            
              
            
            
              <div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-3"><a class="nav-link" href="#2019前端体系及核心知识点总结"><span class="nav-number">1.</span> <span class="nav-text">2019前端体系及核心知识点总结</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#深冻结"><span class="nav-number">1.1.</span> <span class="nav-text">深冻结</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#防抖"><span class="nav-number">1.2.</span> <span class="nav-text">防抖</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#节流"><span class="nav-number">1.3.</span> <span class="nav-text">节流</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#可存储函数执行结果的函数"><span class="nav-number">1.4.</span> <span class="nav-text">可存储函数执行结果的函数</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#将函数转化为-Promise-的使用"><span class="nav-number">1.5.</span> <span class="nav-text">将函数转化为 Promise 的使用</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#函数柯里化"><span class="nav-number">1.6.</span> <span class="nav-text">函数柯里化</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#JS"><span class="nav-number">1.7.</span> <span class="nav-text">JS</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#ES6"><span class="nav-number">1.8.</span> <span class="nav-text">ES6</span></a></li></ol></li></ol></div>
            
          </div>
        </section>
      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">
  
  &copy;  2016 - 
  <span itemprop="copyrightYear">2020</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Marico</span>
</div>

<div class="powered-by">
  由 <a class="theme-link" href="https://hexo.io">Hexo</a> 强力驱动
</div>

<div class="theme-info">
  主题 -
  <a class="theme-link" href="https://github.com/iissnan/hexo-theme-next">
    NexT.Pisces
  </a>
</div>

        

        
      </div>
    </footer>

    <div class="back-to-top">
      <i class="fa fa-arrow-up"></i>
    </div>
  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  



  
  <script type="text/javascript" src="/vendors/jquery/index.js?v=2.1.3"></script>

  
  <script type="text/javascript" src="/vendors/fastclick/lib/fastclick.min.js?v=1.0.6"></script>

  
  <script type="text/javascript" src="/vendors/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>

  
  <script type="text/javascript" src="/vendors/velocity/velocity.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/vendors/velocity/velocity.ui.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/vendors/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.0.1"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.0.1"></script>



  
  


  <script type="text/javascript" src="/js/src/affix.js?v=5.0.1"></script>

  <script type="text/javascript" src="/js/src/schemes/pisces.js?v=5.0.1"></script>



  
  <script type="text/javascript" src="/js/src/scrollspy.js?v=5.0.1"></script>
<script type="text/javascript" src="/js/src/post-details.js?v=5.0.1"></script>



  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.0.1"></script>



  

  
    
  

  <script type="text/javascript">
    var duoshuoQuery = {short_name:"marico-mayue"};
    (function() {
      var ds = document.createElement('script');
      ds.type = 'text/javascript';ds.async = true;
      ds.id = 'duoshuo-script';
      ds.src = (document.location.protocol == 'https:' ? 'https:' : 'http:') + '//static.duoshuo.com/embed.js';
      ds.charset = 'UTF-8';
      (document.getElementsByTagName('head')[0]
      || document.getElementsByTagName('body')[0]).appendChild(ds);
    })();
  </script>

  
    
    <script src="/vendors/ua-parser-js/dist/ua-parser.min.js?v=0.7.9"></script>
    <script src="/js/src/hook-duoshuo.js"></script>
  






  
  

  

  

  

</body>
</html>
